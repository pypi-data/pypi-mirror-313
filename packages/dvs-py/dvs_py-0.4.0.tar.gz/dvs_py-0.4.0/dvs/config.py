import logging
import pathlib
import tempfile
from pathlib import Path
from typing import Literal, Optional, Text

import diskcache
import duckdb
import openai
from faker import Faker
from pydantic import Field, PrivateAttr, SecretStr
from pydantic_settings import BaseSettings
from rich.console import Console

console = Console()
fake = Faker()


class Settings(BaseSettings):
    """
    Settings for the DuckDB VSS API.

    This class defines the configuration parameters for the DuckDB Vector Similarity Search (VSS) API.
    It uses Pydantic's BaseSettings for easy environment variable loading and validation.
    """  # noqa: E501

    APP_NAME: Text = Field(
        default="DVS",
        description="The name of the application. Used for identification and logging purposes.",  # noqa: E501
    )
    APP_VERSION: Text = Field(
        default=pathlib.Path(__file__)
        .resolve()
        .parent.joinpath("VERSION")
        .read_text()
        .strip(),
        description="The version of the application. Follows semantic versioning.",
    )
    APP_ENV: Literal["development", "production", "test"] = Field(
        default="development",
        description="The environment in which the application is running. Affects logging and behavior.",  # noqa: E501
    )
    APP_READY: bool = Field(
        default=False,
        description="Whether the application is ready to serve requests.",
    )
    APP_DATA_DIR: Text = Field(
        default="./data",
        description="The directory where the application stores data.",
    )

    # DuckDB
    DUCKDB_PATH: Text = Field(
        default="./data/documents.duckdb",
        description="The file path to the DuckDB database file containing document and embedding data.",  # noqa: E501
    )
    POINTS_TABLE_NAME: Text = Field(
        default="points",
        description="The name of the table in DuckDB that stores the vector embeddings and related point data.",  # noqa: E501
    )
    DOCUMENTS_TABLE_NAME: Text = Field(
        default="documents",
        description="The name of the table in DuckDB that stores the document metadata.",  # noqa: E501
    )
    EMBEDDING_MODEL: Text = Field(
        default="text-embedding-3-small",
        description="The name of the OpenAI embedding model to use for generating vector embeddings.",  # noqa: E501
    )
    EMBEDDING_DIMENSIONS: int = Field(
        default=512,
        description="The number of dimensions in the vector embeddings generated by the chosen model.",  # noqa: E501
    )

    # OpenAI
    OPENAI_API_KEY: Optional[SecretStr] = Field(
        default=None,
        description="The API key for authenticating with OpenAI services. If not provided, OpenAI features will be disabled.",  # noqa: E501
    )

    # Embeddings
    CACHE_PATH: Text = Field(
        default="./.cache/embeddings.cache",
        description="The file path to the cache directory for storing computed embeddings.",  # noqa: E501
    )
    CACHE_SIZE_LIMIT: int = Field(
        default=100 * 2**20,
        description="The maximum size of the embeddings cache in bytes. Default is 100MB.",  # noqa: E501
    )

    # Properties
    _openai_client: Optional[openai.OpenAI] = PrivateAttr(default=None)
    _cache: Optional[diskcache.Cache] = PrivateAttr(default=None)
    _temp_dir: Path = PrivateAttr(default=Path(tempfile.gettempdir()).joinpath(".dvs"))

    @property
    def openai_client(self) -> openai.OpenAI:
        if self._openai_client is None:
            if self.OPENAI_API_KEY is None:
                raise ValueError("OPENAI_API_KEY is not set")
            self._openai_client = openai.OpenAI(
                api_key=self.OPENAI_API_KEY.get_secret_value()
            )
        return self._openai_client

    @property
    def cache(self) -> diskcache.Cache:
        if self._cache is None:
            self._cache = diskcache.Cache(
                self.CACHE_PATH, size_limit=self.CACHE_SIZE_LIMIT
            )
        return self._cache

    @property
    def duckdb_conn(self) -> duckdb.DuckDBPyConnection:
        return duckdb.connect(self.DUCKDB_PATH)

    def validate_variables(self):
        """
        Validate the variables in the settings.
        """

        # Validate DuckDB path
        if not pathlib.Path(self.DUCKDB_PATH).exists():
            self.APP_READY = False
        else:
            self.DUCKDB_PATH = str(pathlib.Path(self.DUCKDB_PATH).resolve())
            self.APP_READY = True

        # Validate temp directory
        self._temp_dir.mkdir(parents=True, exist_ok=True)

        # Validate app data directory
        _data_dir = pathlib.Path(self.APP_DATA_DIR).resolve()
        _data_dir.mkdir(parents=True, exist_ok=True)
        self.APP_DATA_DIR = str(_data_dir)


settings = Settings()
settings.validate_variables()
logger = logging.getLogger(settings.APP_NAME)
uvicorn_error_logger = logging.getLogger("uvicorn.error")
uvicorn_access_logger = logging.getLogger("uvicorn.access")
