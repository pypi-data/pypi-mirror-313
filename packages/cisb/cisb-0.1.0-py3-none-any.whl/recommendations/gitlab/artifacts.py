from concurrent.futures import ThreadPoolExecutor
from services.common_utils import run_checks


# Define a ThreadPoolExecutor for running I/O bound tasks
executor = ThreadPoolExecutor()


"""4.1.X VERIFICATION"""


def check_4_1_1_artifact_signing(job_artifacts):
    """
    Check if all artifacts are signed by the build pipeline itself.

    Args:
        job_artifacts (dict): A dictionary containing artifacts for each pipeline job.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Reminder:\n"
        "1. Ensure that the build pipeline signs every artifact it produces.\n"
        "2. Verify that a signature file (e.g., .asc, .sig) accompanies each artifact.\n"
        "3. You may use commands such as `gpg --verify` to manually verify the signatures if necessary."
    )

    if not job_artifacts:
        return (
            None,
            f"‚ùå No job artifacts found to verify if they are signed by the build pipeline. {manual_check_message}",
        )

    all_signed = True
    unsigned_artifacts = []

    # Check each artifact for signature files
    for pipeline_id, artifacts in job_artifacts.items():
        if not artifacts:
            print(f"No artifacts found for pipeline {pipeline_id}")
            continue

        pipeline_signed = False
        for artifact in artifacts:
            if isinstance(artifact, dict) and artifact.get(
                "filename", ""
            ).lower().endswith((".asc", ".sig")):
                print(
                    f"‚úÖ Signature found for artifact in pipeline {pipeline_id}: {artifact['filename']}"
                )
                pipeline_signed = True
            else:
                unsigned_artifacts.append(artifact.get("filename", "Unknown"))

        if not pipeline_signed:
            print(f"‚ùå No signatures found for artifacts in pipeline {pipeline_id}")
            all_signed = False

    # Output the last 10 unsigned artifacts
    if not all_signed:
        if unsigned_artifacts:
            last_10_unsigned = unsigned_artifacts[-10:]
            unsigned_message = (
                f"‚ùå Some artifacts are not signed by the build pipeline. "
                f"Here are the last 10 unsigned artifacts: {', '.join(last_10_unsigned)}"
            )
        else:
            unsigned_message = "‚ùå Some artifacts are not signed, but no specific filenames were found."
        return 0, f"{unsigned_message} {manual_check_message}"

    return 5, "‚úÖ All artifacts produced by the build pipeline are signed."


def check_4_1_2_artifact_encryption():
    """
    Manual Check: Ensure that all artifacts are encrypted before distribution.

    Args:
        job_artifacts (dict): A dictionary containing artifacts for each pipeline job.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """
    manual_check_message = (
        "Manual Check Required:\n"
        "1. Inspect the build pipeline and ensure all artifacts generated by the jobs are encrypted.\n"
        "2. Verify encryption methods in the build configuration files (e.g., `.gitlab-ci.yml`).\n"
        "3. Confirm that encryption is applied before the artifacts are distributed or stored.\n"
        "4. Check storage locations (e.g., S3, GCS) to ensure encryption policies are enforced.\n"
        "5. Validate that encryption keys are securely managed and follow best practices.\n"
        "6. Review relevant pipeline job logs or artifact metadata for encryption-related details."
    )

    return (
        None,
        f"Manual review required: Found job artifacts. Verify encryption by following these steps:\n{manual_check_message}",
    )


def check_4_1_3_authorized_decryption():
    """
    Provide a manual check reminder to ensure only authorized platforms have decryption capabilities for artifacts.

    Returns:
        tuple: A tuple containing a compliance score (None since it's manual) and a message (str) with instructions.
    """
    manual_check_message = (
        "üîç **Manual Check Required**: Ensure that only authorized platforms have decryption capabilities of artifacts.\n"
        "Instructions:\n"
        "1. Review the encryption key management policies and ensure that access is limited to authorized platforms only.\n"
        "2. Verify that encryption keys are stored securely using tools like AWS KMS, Azure Key Vault, or HashiCorp Vault.\n"
        "3. Confirm that access to decryption keys is restricted to authorized personnel and systems."
    )

    return None, manual_check_message


"""4.2.X ACCESS TO ARTIFACTS"""


def check_4_2_1_certification_authority_manual():
    """
    Provide a manual check reminder to ensure that the authority to certify artifacts is limited.

    Returns:
        tuple: A tuple containing a compliance score (None since it's manual) and a message (str) with instructions.
    """
    manual_check_message = (
        "üîç **Manual Check Required**: Ensure that only authorized parties have the authority to certify artifacts.\n"
        "\n**Manual Check Instructions**:\n"
        "1. Review your organization's certificate authority policies to confirm that only designated individuals or systems have the capability to certify artifacts.\n"
        "2. Verify that the certificate authority (CA) systems are secure and have restricted access controls.\n"
        "3. Ensure that certification privileges are assigned based on roles and responsibilities, with least privilege principles applied.\n"
        "4. Audit the certification process regularly to confirm that no unauthorized entities have been granted certification authority.\n"
        "5. Check logs for any unusual or unauthorized certification activity to identify potential misuse or breaches."
    )

    return None, manual_check_message


def check_4_2_2_minimize_users_with_upload_permission(project_members):
    """
    Manual check if the number of users with high-level roles who can upload artifacts is minimized.

    Args:
        project_members (list): List of project members with their access levels and roles.

    Returns:
        tuple: A tuple containing a None compliance score and a message for manual review.
    """

    if not project_members:
        return (
            None,
            "‚ùå Unable to fetch project members or no members found. Manual check is required to ensure appropriate permissions.",
        )

    # Filter out bot accounts and token users, and then members with high privilege roles
    high_privilege_roles = ["Owner", "Maintainer"]
    privileged_members = [
        member
        for member in project_members
        if member["access_level"] >= 40
        and "bot" not in member["username"].lower()
        and "token" not in member["username"].lower()
    ]

    if not privileged_members:
        return (
            None,
            "‚úÖ No users with high-level permissions (Owner or Maintainer) found, excluding bots and tokens."
        )

    # Provide details of users with high-level permissions
    member_details = "\n".join(
        [
            f"- {member['name']} ({member['username']}) - Access Level: {member['access_level']}"
            for member in privileged_members
        ]
    )

    message = (
        f"üîç Manual Check Required: {len(privileged_members)} users have high-level permissions to upload artifacts:\n"
        f"{member_details}\n\n"
        "Please ensure that only a minimal number of trusted users hold these roles to maintain security."
    )

    return None, message


def check_4_2_3_mfa_enforcement(group_settings):
    """
    Check if Multi-Factor Authentication (MFA) is enforced for the GitLab group.

    Args:
        group_id (int): The GitLab group ID.
        token (str): GitLab private access token.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """

    if not group_settings:
        return (
            None,
            "‚ùå Unable to retrieve group settings. Please ensure that you have the correct permissions to access the group settings. "
            "To check manually: navigate to your GitLab group, go to 'Settings' > 'General', and look for the 'Sign-in restrictions' section. "
            "Here, ensure that 'Enforce two-factor authentication' is enabled to require MFA for all users.",
        )

    if group_settings.get("require_two_factor_authentication", False):
        return (
            5,
            "‚úÖ Multi-Factor Authentication (MFA) is enforced for the group. All users must use MFA to access the group, which provides an additional layer of security, "
            "ensuring that even if a user's password is compromised, their account is still protected. No further action is needed.",
        )
    else:
        return (
            0,
            "‚ùå Multi-Factor Authentication (MFA) is not currently enforced for this group. It is highly recommended to enable MFA to enhance security. "
            "This prevents unauthorized access even if user passwords are leaked or compromised. "
            "To enable: go to 'Settings' > 'General' in your GitLab group, scroll down to 'Sign-in restrictions', and toggle on 'Enforce two-factor authentication'.",
        )


def check_4_2_4_user_management():
    """
    Manually verify if user management of the package registry is not local.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str) providing instructions for the manual check.
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Open your package registry management console or service (e.g., GitLab, Nexus, Artifactory).\n"
        "2. Check the user management settings to ensure that user access is controlled via an external authentication server such as LDAP or Active Directory (AD).\n"
        "3. Verify that the package registry itself is not managing users directly, and all user authentication is managed centrally by your organization's main authentication server.\n"
        "4. If the package registry offers integration with an external authentication system, make sure it is enabled and configured correctly.\n\n"
        "Note: This step is crucial to avoid multiple points of privilege escalation and maintain a single source of truth for user permissions."
    )

    return None, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


def check_4_2_5_anonymous_access_revoked_using_fetch(project_data):
    """
    Check if anonymous access to artifacts is revoked by verifying that the project's visibility is set to 'private' or 'internal'
    using data fetched from fetch_gitlab_data.

    Args:
        project_data (dict): The project data fetched from the GitLab API.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """
    if not project_data:
        return (
            None,
            "‚ùå Could not fetch project data. Please ensure you have the correct permissions or check the project settings manually.",
        )

    # Extract visibility information
    visibility = project_data.get("visibility", "unknown")

    if visibility in ["private", "internal"]:
        return (
            5,
            f"‚úÖ Anonymous access to artifacts is revoked. The project visibility is set to '{visibility}'.",
        )
    else:
        return 0, (
            f"‚ùå The project visibility is set to '{visibility}'. Anonymous access might be allowed. "
            f"Please set the project visibility to 'private' or 'internal'."
        )


def check_4_2_6_minimum_admins_manual():
    """
    Manual check to ensure the package registry has a minimum number of administrators.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Open your GitLab project and navigate to 'Settings' > 'Members'.\n"
        "2. Review the list of members with 'Owner' or 'Maintainer' roles.\n"
        "3. Ensure that only the necessary and trusted individuals have admin-level access (Owner/Maintainer roles).\n"
        "4. Remove any unnecessary or redundant admin accounts to minimize risk.\n"
        "5. Aim to keep the number of administrators as low as possible to maintain a secure package registry.\n"
        "6. Additionally, check previous compliance checks that have flagged users with admin-level permissions to ensure consistency. "
        "These checks may have identified members with high-level access (e.g., Owners or Maintainers) who should be reviewed."
    )

    return None, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


"""4.3.X PACKAGE REGISTRIES"""


def check_4_3_1_validate_signed_artifacts_manual():
    """
    Manual check to ensure all signed artifacts are validated upon uploading to the package registry.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Go to your GitLab project and navigate to 'Code' > 'Commits'.\n"
        "2. Review the commit history to identify signed commits.\n"
        "3. For each signed commit, check whether it displays a 'Verified' or 'Unverified' badge.\n"
        "4. Make sure that all relevant commits have the 'Verified' badge, indicating that the artifact signatures are validated.\n"
        "5. Repeat this process for merge requests by navigating to 'Code' > 'Merge requests' and reviewing commits within each merge request."
    )

    return None, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


def check_4_3_2_validate_all_artifact_versions_manual():
    """
    Manual check to ensure all versions of an existing artifact have their signatures validated.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Go to your GitLab project and navigate to 'Code' > 'Commits'.\n"
        "2. Review the commit history to identify all versions of the artifact.\n"
        "3. For each version, verify that the commit displays a 'Verified' badge next to its signature.\n"
        "4. Repeat this process for merge requests by navigating to 'Code' > 'Merge requests' and reviewing the commits within each merge request.\n"
        "5. Make sure that all versions of the artifact have valid, verified signatures, indicating they have not been tampered with."
    )

    return None, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


def check_4_3_3_audit_package_registry_configuration():
    """
    Manual check to ensure changes in the package registry configuration are audited.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Go to your GitLab project and navigate to the 'Settings' > 'General' > 'Audit Events' section.\n"
        "2. Review the audit log entries to ensure that all changes related to the package registry configuration are tracked.\n"
        "3. Look for any entries related to changes in the package registry settings, access controls, or visibility configurations.\n"
        "4. Verify that these entries are regularly reviewed and that there is an established process for auditing any changes.\n"
        "5. You can also refer to the GitLab documentation on audit events: https://docs.gitlab.com/ee/administration/audit_event_types.html for more details on what to check."
    )

    return None, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


def check_4_3_4_webhook_security(webhooks):
    """
    Check if all webhooks for a GitLab project are secured (using HTTPS).

    Args:
        project_id (int): The ID of the GitLab project.
        token (str): GitLab personal access token.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """

    insecure_webhooks = []

    # Check each webhook's URL to ensure it's using HTTPS
    for webhook in webhooks:
        if not webhook.get("url", "").lower().startswith("https://"):
            insecure_webhooks.append(webhook["url"])

    if insecure_webhooks:
        return 0, (
            f"‚ùå The following webhooks are not using HTTPS:\n"
            + "\n".join(insecure_webhooks)
            + "\nEnsure all webhooks are updated to use secure URLs (HTTPS)."
        )
    else:
        return 5, "‚úÖ All webhooks are using secure URLs (HTTPS)."


"""4.4.X ORIGIN TRACEABILITY"""


def check_4_4_1_artifact_origin(approval_data):
    """
    Check if artifacts include information about their origin, such as an SBOM or metadata files,
    by verifying if dependency scanning is enabled in the approval settings.

    Args:
        approval_data (list): List of approval rules fetched from GitLab.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Reminder:\n"
        "1. Ensure that every artifact delivered includes information about its origin.\n"
        "2. This information can be in the form of an SBOM or metadata files.\n"
        "3. Review pipeline artifacts for files containing 'sbom', 'metadata', or similar terms that provide origin information."
    )

    if not approval_data:
        return (
            None,
            f"‚ùå No approval data found. Unable to verify if artifacts include origin information. {manual_check_message}",
        )

    dependency_scanning_tool = "dependency_scanning"
    artifact_origin_verified = False

    # Check if dependency scanning is enabled in the approval rules
    for rule in approval_data["rules"]:
        scanners = rule.get("scanners", [])
        if dependency_scanning_tool in scanners:
            artifact_origin_verified = True
            break

    if artifact_origin_verified:
        return (
            5,
            "‚úÖ Artifacts include information about their origin (dependency scanning is enabled in the approval settings).",
        )
    else:
        return (
            0,
            f"‚ùå No origin information found in the pipeline artifacts (dependency scanning is not enabled). {manual_check_message}",
        )

"""Runs every check"""


async def run_artifact_checks(
    job_artifacts,
    project_members,
    group_settings,
    project_data,
    webhooks,
    approval_data
):
    """
    Runs all the artifact-related compliance checks.

    Args:
        job_artifacts (dict): Artifacts information from the pipeline.
        project_members (list): Project members information.
        group_settings (dict): Group settings information.
        project_data (dict): Project data fetched from the GitLab API.
        webhooks (list): List of webhooks for the project.

    Returns:
        dict: A dictionary of check results.
    """
    checks = [
        (check_4_1_1_artifact_signing, [job_artifacts], False),  
        (check_4_1_2_artifact_encryption, [], True),  
        (check_4_1_3_authorized_decryption, [], True),  
        (check_4_2_1_certification_authority_manual, [], True),  
        (
            check_4_2_2_minimize_users_with_upload_permission,
            [project_members],
            True,
        ),  
        (check_4_2_3_mfa_enforcement, [group_settings], False),  
        (check_4_2_4_user_management, [], True),  
        (
            check_4_2_5_anonymous_access_revoked_using_fetch,
            [project_data],
            False,
        ), 
        (check_4_2_6_minimum_admins_manual, [], True),  
        (check_4_3_1_validate_signed_artifacts_manual, [], True),  
        (check_4_3_2_validate_all_artifact_versions_manual, [], True),  
        (check_4_3_3_audit_package_registry_configuration, [], True),
        (check_4_3_4_webhook_security, [webhooks], False), 
        (check_4_4_1_artifact_origin, [approval_data], False), 
    ]

    return run_checks(checks, context_name="Artifact Compliance")
