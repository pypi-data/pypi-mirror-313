from concurrent.futures import ThreadPoolExecutor

# Define a ThreadPoolExecutor for running I/O bound tasks
executor = ThreadPoolExecutor()


"""4.1.X VERIFICATION"""


def check_4_1_1_artifact_signing(job_artifacts):
    """
    Check if all artifacts are signed by the build pipeline itself.

    Args:
        job_artifacts (dict): A dictionary containing artifacts for each pipeline job.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Reminder:\n"
        "1. Ensure that the build pipeline signs every artifact it produces.\n"
        "2. Verify that a signature file (e.g., .asc, .sig) accompanies each artifact.\n"
        "3. You may use commands such as `gpg --verify` to manually verify the signatures if necessary."
    )

    if not job_artifacts:
        return (
            0,
            f"‚ùå No job artifacts found to verify if they are signed by the build pipeline. {manual_check_message}",
        )

    all_signed = True  # Flag to check if all artifacts are signed

    # Check each artifact for signature files
    for pipeline_id, artifacts in job_artifacts.items():
        if artifacts is None:
            print(f"No artifacts found for pipeline {pipeline_id}")
            continue

        pipeline_signed = False

        for artifact in artifacts:
            # Check if artifact is a dictionary
            if not isinstance(artifact, dict):
                print(
                    f"Skipping invalid artifact entry in pipeline {pipeline_id}: {artifact}"
                )
                continue

            filename = artifact.get("filename", "").lower()
            # Check if there's a signature file associated with this artifact
            if filename.endswith((".asc", ".sig")):
                print(
                    f"‚úÖ Signature found for artifact in pipeline {pipeline_id}: {filename}"
                )
                pipeline_signed = True

        # If any pipeline did not have signed artifacts, set the flag to False
        if not pipeline_signed:
            print(f"‚ùå No signatures found for artifacts in pipeline {pipeline_id}")
            all_signed = False

    if all_signed:
        return 5, "‚úÖ All artifacts produced by the build pipeline are signed."
    else:
        return (
            0,
            f"‚ùå Some artifacts are not signed by the build pipeline. {manual_check_message}",
        )


def check_4_1_2_artifact_encryption(job_artifacts):
    """
    Check if all artifacts are encrypted before distribution.

    Args:
        job_artifacts (dict): A dictionary containing artifacts for each pipeline job.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Reminder:\n"
        "1. Ensure that every artifact generated by the build pipeline is encrypted before distribution.\n"
        "2. Verify encryption settings in the build configuration files (e.g., .gitlab-ci.yml) or in your deployment scripts.\n"
        "3. Check that encryption keys are managed securely and that only authorized platforms have decryption capabilities.\n"
        "4. Consider using encryption standards such as AES-256 for securing artifacts."
    )

    if not job_artifacts:
        return (
            0,
            f"‚ùå No job artifacts found to verify if they are encrypted. {manual_check_message}",
        )

    # Check if artifacts indicate encryption status (This depends on available metadata from the API)
    encryption_verified = False
    for pipeline_id, artifacts in job_artifacts.items():
        if artifacts is None:
            print(f"No artifacts found for pipeline {pipeline_id}")
            continue

        for artifact in artifacts:
            # Check if there's metadata indicating encryption (Adjust this as needed based on your system)
            if not isinstance(artifact, dict):
                print(
                    f"Skipping invalid artifact entry in pipeline {pipeline_id}: {artifact}"
                )
                continue

            # Assume there is a key 'is_encrypted' that might indicate encryption status
            if artifact.get("is_encrypted", False):
                print(
                    f"‚úÖ Encrypted artifact found in pipeline {pipeline_id}: {artifact['filename']}"
                )
                encryption_verified = True
            else:
                print(
                    f"‚ö†Ô∏è Artifact not explicitly marked as encrypted in pipeline {pipeline_id}: {artifact['filename']}"
                )

    if encryption_verified:
        return 5, "‚úÖ Artifacts are encrypted before distribution."
    else:
        return (
            0,
            f"‚ùå No confirmation of encryption found for the artifacts. {manual_check_message}",
        )


def check_4_1_3_authorized_decryption():
    """
    Provide a manual check reminder to ensure only authorized platforms have decryption capabilities for artifacts.

    Returns:
        tuple: A tuple containing a compliance score (None since it's manual) and a message (str) with instructions.
    """
    manual_check_message = (
        "üîç **Manual Check Required**: Ensure that only authorized platforms have decryption capabilities of artifacts.\n"
        "\n**Manual Check Instructions**:\n"
        "1. Review the encryption key management policies and ensure that access is limited to authorized platforms only.\n"
        "2. Verify that encryption keys are stored securely using tools like AWS KMS, Azure Key Vault, or HashiCorp Vault.\n"
        "3. Confirm that access to decryption keys is restricted to authorized personnel and systems through access control policies.\n"
        "4. Check the access logs regularly to ensure there have been no unauthorized attempts to access decryption capabilities.\n"
        "5. Ensure that any platform or service accessing the artifacts for decryption is reviewed and authorized according to your organization's policies."
    )

    return None, manual_check_message


"""4.2.X ACCESS TO ARTIFACTS"""


def check_4_2_1_certification_authority_manual():
    """
    Provide a manual check reminder to ensure that the authority to certify artifacts is limited.

    Returns:
        tuple: A tuple containing a compliance score (None since it's manual) and a message (str) with instructions.
    """
    manual_check_message = (
        "üîç **Manual Check Required**: Ensure that only authorized parties have the authority to certify artifacts.\n"
        "\n**Manual Check Instructions**:\n"
        "1. Review your organization's certificate authority policies to confirm that only designated individuals or systems have the capability to certify artifacts.\n"
        "2. Verify that the certificate authority (CA) systems are secure and have restricted access controls.\n"
        "3. Ensure that certification privileges are assigned based on roles and responsibilities, with least privilege principles applied.\n"
        "4. Audit the certification process regularly to confirm that no unauthorized entities have been granted certification authority.\n"
        "5. Check logs for any unusual or unauthorized certification activity to identify potential misuse or breaches."
    )

    return None, manual_check_message


def check_4_2_2_minimize_users_with_upload_permission(project_members):
    """
    Check if the number of users with high-level roles who can upload artifacts is minimized.

    Args:
        project_id (int): The GitLab project ID.
        token (str): GitLab private access token.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """

    if not project_members:
        return (
            0,
            "‚ùå Unable to fetch project members or no members found. Manual check is required.",
        )

    # Filter out members with roles that allow them to upload artifacts
    high_privilege_roles = ["Owner", "Maintainer"]
    privileged_members = [
        member for member in project_members if member["access_level"] >= 40
    ]  # Access levels: Owner = 50, Maintainer = 40

    if not privileged_members:
        return (
            5,
            "‚úÖ No users with high-level permissions (Owner or Maintainer) have access to upload artifacts.",
        )

    # Provide details of users with high-level permissions
    member_details = "\n".join(
        [
            f"- {member['name']} ({member['username']}) - {member['access_level']}"
            for member in privileged_members
        ]
    )

    return (
        0,
        f"‚ùå {len(privileged_members)} users have high-level permissions to upload artifacts:\n{member_details}\n"
        "Please ensure that only a minimal number of trusted users have these roles.",
    )


def check_4_2_3_mfa_enforcement(group_settings):
    """
    Check if Multi-Factor Authentication (MFA) is enforced for the GitLab group.

    Args:
        group_id (int): The GitLab group ID.
        token (str): GitLab private access token.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """

    if not group_settings:
        return (
            0,
            "‚ùå Unable to fetch group settings. Please check manually if MFA is enforced for the group.",
        )

    if group_settings.get("require_two_factor_authentication", False):
        return (
            5,
            "‚úÖ MFA is enforced for the group. All users are required to use Multi-Factor Authentication.",
        )
    else:
        return (
            0,
            "‚ùå MFA is not enforced for the group. Please enable 'require_two_factor_authentication' in group settings.",
        )


def check_4_2_4_user_management():
    """
    Manually verify if user management of the package registry is not local.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str) providing instructions for the manual check.
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Open your package registry management console or service (e.g., GitLab, Nexus, Artifactory).\n"
        "2. Check the user management settings to ensure that user access is controlled via an external authentication server such as LDAP or Active Directory (AD).\n"
        "3. Verify that the package registry itself is not managing users directly, and all user authentication is managed centrally by your organization's main authentication server.\n"
        "4. If the package registry offers integration with an external authentication system, make sure it is enabled and configured correctly.\n\n"
        "Note: This step is crucial to avoid multiple points of privilege escalation and maintain a single source of truth for user permissions."
    )

    return 0, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


def check_4_2_5_anonymous_access_revoked_using_fetch(project_data):
    """
    Check if anonymous access to artifacts is revoked by verifying that the project's visibility is set to 'private' or 'internal'
    using data fetched from fetch_gitlab_data.

    Args:
        project_data (dict): The project data fetched from the GitLab API.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """
    if not project_data:
        return (
            0,
            "‚ùå Could not fetch project data. Please ensure you have the correct permissions or check the project settings manually.",
        )

    # Extract visibility information
    visibility = project_data.get("visibility", "unknown")

    if visibility in ["private", "internal"]:
        return (
            5,
            f"‚úÖ Anonymous access to artifacts is revoked. The project visibility is set to '{visibility}'.",
        )
    else:
        return 0, (
            f"‚ùå The project visibility is set to '{visibility}'. Anonymous access might be allowed. "
            f"Please set the project visibility to 'private' or 'internal'."
        )


def check_4_2_6_minimum_admins_manual():
    """
    Manual check to ensure the package registry has a minimum number of administrators.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Open your GitLab project and navigate to 'Settings' > 'Members'.\n"
        "2. Review the list of members with 'Owner' or 'Maintainer' roles.\n"
        "3. Ensure that only the necessary and trusted individuals have admin-level access (Owner/Maintainer roles).\n"
        "4. Remove any unnecessary or redundant admin accounts to minimize risk.\n"
        "5. Aim to keep the number of administrators as low as possible to maintain a secure package registry."
    )

    return 0, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


"""4.3.X PACKAGE REGISTRIES"""


def check_4_3_1_validate_signed_artifacts_manual():
    """
    Manual check to ensure all signed artifacts are validated upon uploading to the package registry.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Go to your GitLab project and navigate to 'Code' > 'Commits'.\n"
        "2. Review the commit history to identify signed commits.\n"
        "3. For each signed commit, check whether it displays a 'Verified' or 'Unverified' badge.\n"
        "4. Make sure that all relevant commits have the 'Verified' badge, indicating that the artifact signatures are validated.\n"
        "5. Repeat this process for merge requests by navigating to 'Code' > 'Merge requests' and reviewing commits within each merge request."
    )

    return 0, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


def check_4_3_2_validate_all_artifact_versions_manual():
    """
    Manual check to ensure all versions of an existing artifact have their signatures validated.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Go to your GitLab project and navigate to 'Code' > 'Commits'.\n"
        "2. Review the commit history to identify all versions of the artifact.\n"
        "3. For each version, verify that the commit displays a 'Verified' badge next to its signature.\n"
        "4. Repeat this process for merge requests by navigating to 'Code' > 'Merge requests' and reviewing the commits within each merge request.\n"
        "5. Make sure that all versions of the artifact have valid, verified signatures, indicating they have not been tampered with."
    )

    return 0, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


def check_4_3_3_audit_package_registry_configuration():
    """
    Manual check to ensure changes in the package registry configuration are audited.

    Returns:
        tuple: A tuple containing the compliance score (0 since it's a manual check) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Required:\n"
        "1. Go to your GitLab project and navigate to the 'Settings' > 'General' > 'Audit Events' section.\n"
        "2. Review the audit log entries to ensure that all changes related to the package registry configuration are tracked.\n"
        "3. Look for any entries related to changes in the package registry settings, access controls, or visibility configurations.\n"
        "4. Verify that these entries are regularly reviewed and that there is an established process for auditing any changes.\n"
        "5. You can also refer to the GitLab documentation on audit events: https://docs.gitlab.com/ee/administration/audit_event_types.html for more details on what to check."
    )

    return 0, f"‚ö†Ô∏è This check requires manual verification. {manual_check_message}"


def check_4_3_4_webhook_security(webhooks):
    """
    Check if all webhooks for a GitLab project are secured (using HTTPS).

    Args:
        project_id (int): The ID of the GitLab project.
        token (str): GitLab personal access token.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """

    insecure_webhooks = []

    # Check each webhook's URL to ensure it's using HTTPS
    for webhook in webhooks:
        if not webhook.get("url", "").lower().startswith("https://"):
            insecure_webhooks.append(webhook["url"])

    if insecure_webhooks:
        return 0, (
            f"‚ùå The following webhooks are not using HTTPS:\n"
            + "\n".join(insecure_webhooks)
            + "\nEnsure all webhooks are updated to use secure URLs (HTTPS)."
        )
    else:
        return 5, "‚úÖ All webhooks are using secure URLs (HTTPS)."


"""4.4.X ORIGIN TRACEABILITY"""


def check_4_4_1_artifact_origin(job_artifacts):
    """
    Check if artifacts contain information about their origin, such as an SBOM or metadata files.

    Args:
        job_artifacts (dict): A dictionary containing the artifacts from each pipeline job.

    Returns:
        tuple: A tuple containing the compliance score (int) and a message (str).
    """
    manual_check_message = (
        "\nManual Check Reminder:\n"
        "1. Ensure that every artifact delivered includes information about its origin.\n"
        "2. This information can be in the form of an SBOM or metadata files.\n"
        "3. Look for files containing 'sbom', 'metadata', or similar terms that provide origin information."
    )

    if not job_artifacts:
        return (
            0,
            f"‚ùå No job artifacts found to verify their origin information. {manual_check_message}",
        )

    origin_info_found = False

    # Check if any artifacts contain SBOM data or metadata
    for pipeline_id, artifacts in job_artifacts.items():
        if artifacts is None:
            print(f"No artifacts found for pipeline {pipeline_id}")
            continue

        for artifact in artifacts:
            # Check for common SBOM file names or metadata indicators
            if (
                artifact.get("filename", "")
                .lower()
                .endswith((".spdx", ".json", ".xml", ".bom", "metadata"))
                or "sbom" in artifact.get("filename", "").lower()
            ):
                print(
                    f"‚úÖ Origin information found for pipeline {pipeline_id}: {artifact['filename']}"
                )
                origin_info_found = True

    if origin_info_found:
        return 5, "‚úÖ Artifacts contain information about their origin."
    else:
        return (
            0,
            f"‚ùå No origin information (SBOM or metadata) found in the pipeline job artifacts. {manual_check_message}",
        )


"""Runs every check"""


async def run_all_checks(
    job_artifacts,
    project_members,
    group_settings,
    project_data,
    webhooks,
):
    """Run all the checks defined in this file."""
    total_score = 0
    results = {}  # Dictionary to store check results

    checks = [
        (check_4_1_1_artifact_signing, [job_artifacts], True),
        (check_4_1_2_artifact_encryption, [job_artifacts], False),
        (check_4_1_3_authorized_decryption, [], False),
        (check_4_2_1_certification_authority_manual, [], False),
        (check_4_2_2_minimize_users_with_upload_permission, [project_members], True),
        (check_4_2_3_mfa_enforcement, [group_settings], True),
        (check_4_2_4_user_management, [], False),
        (check_4_2_5_anonymous_access_revoked_using_fetch, [project_data], True),
        (check_4_2_6_minimum_admins_manual, [], False),
        (check_4_3_1_validate_signed_artifacts_manual, [], False),
        (check_4_3_2_validate_all_artifact_versions_manual, [], False),
        (check_4_3_3_audit_package_registry_configuration, [], False),
        (check_4_3_4_webhook_security, [webhooks], True),
        (check_4_4_1_artifact_origin, [job_artifacts], True),
    ]

    for check, args, is_automated in checks:
        print(f"Running {check.__name__}...")
        result = check(*args)  # Call the function with unpacked arguments

        # Handle both tuple (compliance score and message) results
        if isinstance(result, tuple):
            score, message = result
            if is_automated:
                total_score += score  # Accumulate the score only for automated checks
            results[check.__name__] = message  # Save the message
            print(message)  # Print the message to the console
        elif isinstance(result, int):
            if is_automated:
                total_score += result  # Accumulate the score only for automated checks
            results[check.__name__] = result  # Save the score

        print("\n")  # Add space after each check's output

    # Calculate total possible score based only on the number of automated checks
    total_possible_score = len([check for check in checks if check[2]]) * 5

    print("\n===========================")
    print(f"Total artifacts compliance score: {total_score}/{total_possible_score}")
    print("===========================")

    # Return both score and detailed results for manual checks
    return results
