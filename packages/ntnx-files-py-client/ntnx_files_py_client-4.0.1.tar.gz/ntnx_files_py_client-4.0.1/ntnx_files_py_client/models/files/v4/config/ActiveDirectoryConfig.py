# coding: utf-8


"""
IGNORE:
    Nutanix Files APIs

    Manage virtual file servers, create and configure shares for client access, protect them using DR and sync policies, provision storage space and administer security controls.  # noqa: E501

    OpenAPI spec version: 4.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from pathlib import Path
from ntnx_files_py_client.models.files.v4.config.Credential import Credential  # noqa: F401,E501
from ntnx_files_py_client.models.files.v4.config.ProtocolType import ProtocolType  # noqa: F401,E501

class ActiveDirectoryConfig(object):

    """AD domain associated with the file server.

    :param credential: (:attr:`credential`) 
    :type credential: 
    
    
    :param domain_name: (:attr:`domain_name`) AD domain name associated with the file server. Ex. child4.afs.minerva.com
    :type domain_name: 
     max=255 chars
    
    :param organization_unit: (:attr:`organization_unit`) AD domain organizational unit associated with the file server. Ex. OU=AFS represents an organizational unit named AFS.
    :type organization_unit: 
     max=63 chars
    
    :param should_overwrite_user_account: (:attr:`should_overwrite_user_account`) If a machine account with the same name as file server name is present on the Ad, then overwrite it during join-domain operation. (**Default** False)
    :type should_overwrite_user_account: 
    
    
    :param preferred_domain_controller: (:attr:`preferred_domain_controller`) Use a specific domain controller for the join-domain operation in a multi-DC active directory setup. By default, AFS discovers a site local domain controller for join-domain operation. The preferred domain controller cannot be an IP address. It has to be FQDN (example: dc_name.dom.companyname.com)
    :type preferred_domain_controller: 
    
    
    :param should_add_user_as_fs_admin: (:attr:`should_add_user_as_fs_admin`) AD user or group name as 'name' or 'NETBIOS\\name' format. (**Default** False)
    :type should_add_user_as_fs_admin: 
    
    
    :param protocol_type: (:attr:`protocol_type`) 
    :type protocol_type: 
    
    
    :param is_rfc2307_enabled: (:attr:`is_rfc2307_enabled`) RFC 2307 ENABLED (true, false). (**Default** False)
    :type is_rfc2307_enabled: 
    
    
    :param should_use_same_credentials_for_dns: (:attr:`should_use_same_credentials_for_dns`) Use the same AD credential for DNS. (**Default** False)
    :type should_use_same_credentials_for_dns: 
    
    
    :param should_force_leave_domain: (:attr:`should_force_leave_domain`) If the joined active directory is down or not reachable, then set this field to true to leave the domain by bypassing all AD interactions. Ensure to remove the file server machine account manually afterwards. (**Default** False)
    :type should_force_leave_domain: 
    
    
    :param should_validate_ad_credential: (:attr:`should_validate_ad_credential`) Indicates whether the AD credentials will be validated or skipped. (**Default** False)
    :type should_validate_ad_credential: 
    
    

    """
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """  # noqa: E501
    swagger_types = {
        'credential': 'files.v4.config.Credential',
        'domain_name': 'str',
        'organization_unit': 'str',
        'should_overwrite_user_account': 'bool',
        'preferred_domain_controller': 'str',
        'should_add_user_as_fs_admin': 'bool',
        'protocol_type': 'files.v4.config.ProtocolType',
        'is_rfc2307_enabled': 'bool',
        'should_use_same_credentials_for_dns': 'bool',
        'should_force_leave_domain': 'bool',
        'should_validate_ad_credential': 'bool',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'credential': 'credential',
        'domain_name': 'domainName',
        'organization_unit': 'organizationUnit',
        'should_overwrite_user_account': 'shouldOverwriteUserAccount',
        'preferred_domain_controller': 'preferredDomainController',
        'should_add_user_as_fs_admin': 'shouldAddUserAsFsAdmin',
        'protocol_type': 'protocolType',
        'is_rfc2307_enabled': 'isRfc2307Enabled',
        'should_use_same_credentials_for_dns': 'shouldUseSameCredentialsForDns',
        'should_force_leave_domain': 'shouldForceLeaveDomain',
        'should_validate_ad_credential': 'shouldValidateAdCredential',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, credential=None, domain_name=None, organization_unit=None, should_overwrite_user_account=False, preferred_domain_controller=None, should_add_user_as_fs_admin=False, protocol_type=None, is_rfc2307_enabled=False, should_use_same_credentials_for_dns=False, should_force_leave_domain=False, should_validate_ad_credential=False, *args, **kwargs):  # noqa: E501
        self.__credential = None
        self.__domain_name = None
        self.__organization_unit = None
        self.__should_overwrite_user_account = None
        self.__preferred_domain_controller = None
        self.__should_add_user_as_fs_admin = None
        self.__protocol_type = None
        self.__is_rfc2307_enabled = None
        self.__should_use_same_credentials_for_dns = None
        self.__should_force_leave_domain = None
        self.__should_validate_ad_credential = None
        self.discriminator = None
        if credential is not None:
            self.__credential = credential
        if domain_name is not None:
            self.__domain_name = domain_name
        if organization_unit is not None:
            self.__organization_unit = organization_unit
        if should_overwrite_user_account is not None:
            self.__should_overwrite_user_account = should_overwrite_user_account
        if preferred_domain_controller is not None:
            self.__preferred_domain_controller = preferred_domain_controller
        if should_add_user_as_fs_admin is not None:
            self.__should_add_user_as_fs_admin = should_add_user_as_fs_admin
        if protocol_type is not None:
            self.__protocol_type = protocol_type
        if is_rfc2307_enabled is not None:
            self.__is_rfc2307_enabled = is_rfc2307_enabled
        if should_use_same_credentials_for_dns is not None:
            self.__should_use_same_credentials_for_dns = should_use_same_credentials_for_dns
        if should_force_leave_domain is not None:
            self.__should_force_leave_domain = should_force_leave_domain
        if should_validate_ad_credential is not None:
            self.__should_validate_ad_credential = should_validate_ad_credential
        # populate hidden vars if not empty
        self._populate_hidden_vars(kwargs)

    def _initialize_object_type(self):
        return 'files.v4.config.ActiveDirectoryConfig'

    def _initialize_object_version(self):
        return 'v4.r0'

    def _populate_hidden_vars(self, kwargs):
        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
            self.__dollar_reserved = kwargs["_reserved"]
        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
        else :
            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
        else :
            self.__dollar_unknown_fields = {}
        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
            self.__dollar_object_type = kwargs["_object_type"]
        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
        else:
            self.__dollar_object_type = self._initialize_object_type()

    def get_object_type(self):
        return self.__dollar_object_type

    def get_reserved(self):
        return self.__dollar_reserved

    def get_unknown_fields(self):
        return self.__dollar_unknown_fields

    @property
    def credential(self):
        """
        

        :type:
            :class:`~ntnx_files_py_client.models.files.v4.config.Credential`
        """  # noqa: E501
        return self.__credential

    @credential.setter
    def credential(self, credential):

        self.__credential = credential

    @property
    def domain_name(self):
        """
        AD domain name associated with the file server. Ex. child4.afs.minerva.com

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__domain_name

    @domain_name.setter
    def domain_name(self, domain_name):
        if domain_name is not None and len(domain_name) > 255:
            raise ValueError("Invalid value for `domain_name`, length must be less than or equal to `255`")  # noqa: E501
        if domain_name is not None and not re.search('^([a-z0-9]+(-[a-z0-9]+)*\\.)+([a-z0-9]+(-[a-z0-9]+)*){1,63}$', domain_name):  # noqa: E501
            raise ValueError(r"Invalid value for `domain_name`, must be a follow pattern or equal to `/^([a-z0-9]+(-[a-z0-9]+)*\\.)+([a-z0-9]+(-[a-z0-9]+)*){1,63}$/`")  # noqa: E501

        self.__domain_name = domain_name

    @property
    def organization_unit(self):
        """
        AD domain organizational unit associated with the file server. Ex. OU=AFS represents an organizational unit named AFS.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__organization_unit

    @organization_unit.setter
    def organization_unit(self, organization_unit):
        if organization_unit is not None and len(organization_unit) > 63:
            raise ValueError("Invalid value for `organization_unit`, length must be less than or equal to `63`")  # noqa: E501

        self.__organization_unit = organization_unit

    @property
    def should_overwrite_user_account(self):
        """
        If a machine account with the same name as file server name is present on the Ad, then overwrite it during join-domain operation.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_overwrite_user_account

    @should_overwrite_user_account.setter
    def should_overwrite_user_account(self, should_overwrite_user_account):

        self.__should_overwrite_user_account = should_overwrite_user_account

    @property
    def preferred_domain_controller(self):
        """
        Use a specific domain controller for the join-domain operation in a multi-DC active directory setup. By default, AFS discovers a site local domain controller for join-domain operation. The preferred domain controller cannot be an IP address. It has to be FQDN (example: dc_name.dom.companyname.com)

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__preferred_domain_controller

    @preferred_domain_controller.setter
    def preferred_domain_controller(self, preferred_domain_controller):
        if preferred_domain_controller is not None and not re.search('^([a-z0-9]+(-[a-z0-9]+)*\\.)+([a-z0-9]+(-[a-z0-9]+)*){1,63}$', preferred_domain_controller):  # noqa: E501
            raise ValueError(r"Invalid value for `preferred_domain_controller`, must be a follow pattern or equal to `/^([a-z0-9]+(-[a-z0-9]+)*\\.)+([a-z0-9]+(-[a-z0-9]+)*){1,63}$/`")  # noqa: E501

        self.__preferred_domain_controller = preferred_domain_controller

    @property
    def should_add_user_as_fs_admin(self):
        """
        AD user or group name as 'name' or 'NETBIOS\\name' format.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_add_user_as_fs_admin

    @should_add_user_as_fs_admin.setter
    def should_add_user_as_fs_admin(self, should_add_user_as_fs_admin):

        self.__should_add_user_as_fs_admin = should_add_user_as_fs_admin

    @property
    def protocol_type(self):
        """
        

        :type:
            :class:`~ntnx_files_py_client.models.files.v4.config.ProtocolType`
        """  # noqa: E501
        return self.__protocol_type

    @protocol_type.setter
    def protocol_type(self, protocol_type):

        self.__protocol_type = protocol_type

    @property
    def is_rfc2307_enabled(self):
        """
        RFC 2307 ENABLED (true, false).

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_rfc2307_enabled

    @is_rfc2307_enabled.setter
    def is_rfc2307_enabled(self, is_rfc2307_enabled):

        self.__is_rfc2307_enabled = is_rfc2307_enabled

    @property
    def should_use_same_credentials_for_dns(self):
        """
        Use the same AD credential for DNS.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_use_same_credentials_for_dns

    @should_use_same_credentials_for_dns.setter
    def should_use_same_credentials_for_dns(self, should_use_same_credentials_for_dns):

        self.__should_use_same_credentials_for_dns = should_use_same_credentials_for_dns

    @property
    def should_force_leave_domain(self):
        """
        If the joined active directory is down or not reachable, then set this field to true to leave the domain by bypassing all AD interactions. Ensure to remove the file server machine account manually afterwards.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_force_leave_domain

    @should_force_leave_domain.setter
    def should_force_leave_domain(self, should_force_leave_domain):

        self.__should_force_leave_domain = should_force_leave_domain

    @property
    def should_validate_ad_credential(self):
        """
        Indicates whether the AD credentials will be validated or skipped.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_validate_ad_credential

    @should_validate_ad_credential.setter
    def should_validate_ad_credential(self, should_validate_ad_credential):

        self.__should_validate_ad_credential = should_validate_ad_credential

    @property
    def _reserved(self):
        """
        

        :type:
            dict(str, :class:`~object`)
        """  # noqa: E501
        return self.__dollar_reserved

    @property
    def _object_type(self):
        """
        

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__dollar_object_type

    @property
    def _unknown_fields(self):
        """
        

        :type:
            dict(str, :class:`~object`)
        """  # noqa: E501
        return self.__dollar_unknown_fields

    def _to_dict(self, sanitize):
        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.

        :param sanitize: A flag to omit None properties if set to True
        :type sanitize: bool
        """

        result = {}
        for attr, attr_type in six.iteritems(self.swagger_types):

            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, Path):
                result[attr] = str(value)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
                    else (
                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
                        else item
                    ),
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(ActiveDirectoryConfig, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        return result

    def to_dict(self):
        """Returns the model properties as a dictionary"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ActiveDirectoryConfig):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

