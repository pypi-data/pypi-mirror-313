# coding: utf-8


"""
IGNORE:
    Nutanix Files APIs

    Manage virtual file servers, create and configure shares for client access, protect them using DR and sync policies, provision storage space and administer security controls.  # noqa: E501

    OpenAPI spec version: 4.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from pathlib import Path
from ntnx_files_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
from ntnx_files_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501
from ntnx_files_py_client.models.files.v4.config.MigrationStatus import MigrationStatus  # noqa: F401,E501
from ntnx_files_py_client.models.files.v4.config.MountTargetProtocolType import MountTargetProtocolType  # noqa: F401,E501

class MigrationSubPlan(ExternalizableAbstractModel):

    """Migration sub-plan details.

    :param name: (:attr:`name`) Migration sub-plan name
    :type name: required
     min=1 chars, max=30 chars
    
    :param source_path: (:attr:`source_path`) Source path
    :type source_path: required
     min=1 chars, max=4096 chars
    
    :param target_path: (:attr:`target_path`) Target path
    :type target_path: 
     max=4096 chars
    
    :param target_mount_target_ext_id: (:attr:`target_mount_target_ext_id`) Target mount-target extId.
    :type target_mount_target_ext_id: required
    
    
    :param is_sync_type_mirror: (:attr:`is_sync_type_mirror`) Indicates the flag for sync type. If false, then only the source will be synced. The delete and rename are not honored on the target, if anything is deleted or renamed on the source. If true, then the source will be mirrored on the target, that is, every delete and rename will be honored. (**Default** False)
    :type is_sync_type_mirror: 
    
    
    :param status: (:attr:`status`) 
    :type status: 
    
    
    :param status_msg: (:attr:`status_msg`) Indicates the status message of the migration sub-plan. It updates after each migration step, informing the current migration sub-plan stage. This is a read-only field.
    :type status_msg: 
     max=4096 chars
    
    :param is_final_iteration: (:attr:`is_final_iteration`) A flag to identify if its final iteration. This flag should be given as true to do the final round of migration. It is recommended to keep the sub-plan source as readonly to migrate all the content from the source to the target. We prioritize such an iteration so that the read-only time for the source can be decreased by utilising migrator resources only for the subplans in final iteration. After the completion of this iteration, if no failed files are found, we need to update the sub-plan status as COMPLETED, and no further action on this sub-plan will be allowed. If there are failed files under max-limit while migration, the subplan status will be changed to succeded and you will have numberOfFilesFailed/numberOfDirectoriesFailed/numberOfStreamsFailed on migration job. These failed files name and error can be retrieved using GET failed-files-summary API, and upon error correction, the user can start another iteration to sync failed files only the flag shouldRetryOnlyFailedFiles flag. (**Default** False)
    :type is_final_iteration: 
    
    
    :param should_allow_unknown_sids: (:attr:`should_allow_unknown_sids`) A flag to indicate whether unknown SIDs should be allowed during migration instead of failing it. (**Default** True)
    :type should_allow_unknown_sids: 
    
    
    :param should_ignore_long_tld_names: (:attr:`should_ignore_long_tld_names`) A flag to indicate whether long TLD name should be ignored while migration instead of failing it. (**Default** True)
    :type should_ignore_long_tld_names: 
    
    
    :param should_ignore_files_at_root: (:attr:`should_ignore_files_at_root`) A flag to indicate whether files at root should be ignored while migration instead of failing it. (**Default** True)
    :type should_ignore_files_at_root: 
    
    
    :param should_retry_only_failed_files: (:attr:`should_retry_only_failed_files`) A flag to indicate whether the migration iteration is only to migrate failed files/directories from the last iteration. If it is false and status is changed to running from default, then the migration will start for the whole source mount target. If it is true, then only a list of failed files from the last iteration are retried for migration. (**Default** False)
    :type should_retry_only_failed_files: 
    
    
    :param protocol: (:attr:`protocol`) 
    :type protocol: 
    
    

    """
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """  # noqa: E501
    swagger_types = {
        'name': 'str',
        'source_path': 'str',
        'target_path': 'str',
        'target_mount_target_ext_id': 'str',
        'is_sync_type_mirror': 'bool',
        'status': 'files.v4.config.MigrationStatus',
        'status_msg': 'str',
        'is_final_iteration': 'bool',
        'should_allow_unknown_sids': 'bool',
        'should_ignore_long_tld_names': 'bool',
        'should_ignore_files_at_root': 'bool',
        'should_retry_only_failed_files': 'bool',
        'protocol': 'files.v4.config.MountTargetProtocolType',
        'ext_id': 'str',
        'links': 'list[common.v1.response.ApiLink]',
        'tenant_id': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'name': 'name',
        'source_path': 'sourcePath',
        'target_path': 'targetPath',
        'target_mount_target_ext_id': 'targetMountTargetExtId',
        'is_sync_type_mirror': 'isSyncTypeMirror',
        'status': 'status',
        'status_msg': 'statusMsg',
        'is_final_iteration': 'isFinalIteration',
        'should_allow_unknown_sids': 'shouldAllowUnknownSids',
        'should_ignore_long_tld_names': 'shouldIgnoreLongTldNames',
        'should_ignore_files_at_root': 'shouldIgnoreFilesAtRoot',
        'should_retry_only_failed_files': 'shouldRetryOnlyFailedFiles',
        'protocol': 'protocol',
        'ext_id': 'extId',
        'links': 'links',
        'tenant_id': 'tenantId',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, name=None, source_path=None, target_path=None, target_mount_target_ext_id=None, is_sync_type_mirror=False, status=None, status_msg=None, is_final_iteration=False, should_allow_unknown_sids=True, should_ignore_long_tld_names=True, should_ignore_files_at_root=True, should_retry_only_failed_files=False, protocol=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
        self.__name = None
        self.__source_path = None
        self.__target_path = None
        self.__target_mount_target_ext_id = None
        self.__is_sync_type_mirror = None
        self.__status = None
        self.__status_msg = None
        self.__is_final_iteration = None
        self.__should_allow_unknown_sids = None
        self.__should_ignore_long_tld_names = None
        self.__should_ignore_files_at_root = None
        self.__should_retry_only_failed_files = None
        self.__protocol = None
        self.discriminator = None
        self.__name = name
        self.__source_path = source_path
        if target_path is not None:
            self.__target_path = target_path
        self.__target_mount_target_ext_id = target_mount_target_ext_id
        if is_sync_type_mirror is not None:
            self.__is_sync_type_mirror = is_sync_type_mirror
        if status is not None:
            self.__status = status
        if status_msg is not None:
            self.__status_msg = status_msg
        if is_final_iteration is not None:
            self.__is_final_iteration = is_final_iteration
        if should_allow_unknown_sids is not None:
            self.__should_allow_unknown_sids = should_allow_unknown_sids
        if should_ignore_long_tld_names is not None:
            self.__should_ignore_long_tld_names = should_ignore_long_tld_names
        if should_ignore_files_at_root is not None:
            self.__should_ignore_files_at_root = should_ignore_files_at_root
        if should_retry_only_failed_files is not None:
            self.__should_retry_only_failed_files = should_retry_only_failed_files
        if protocol is not None:
            self.__protocol = protocol

    def _initialize_object_type(self):
        return 'files.v4.config.MigrationSubPlan'

    def _initialize_object_version(self):
        return 'v4.r0'


    @property
    def name(self):
        """
        Migration sub-plan name

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__name

    @name.setter
    def name(self, name):
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
        if name is not None and len(name) > 30:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `30`")  # noqa: E501
        if name is not None and len(name) < 1:
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")  # noqa: E501

        self.__name = name

    @property
    def source_path(self):
        """
        Source path

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__source_path

    @source_path.setter
    def source_path(self, source_path):
        if source_path is None:
            raise ValueError("Invalid value for `source_path`, must not be `None`")  # noqa: E501
        if source_path is not None and len(source_path) > 4096:
            raise ValueError("Invalid value for `source_path`, length must be less than or equal to `4096`")  # noqa: E501
        if source_path is not None and len(source_path) < 1:
            raise ValueError("Invalid value for `source_path`, length must be greater than or equal to `1`")  # noqa: E501

        self.__source_path = source_path

    @property
    def target_path(self):
        """
        Target path

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__target_path

    @target_path.setter
    def target_path(self, target_path):
        if target_path is not None and len(target_path) > 4096:
            raise ValueError("Invalid value for `target_path`, length must be less than or equal to `4096`")  # noqa: E501

        self.__target_path = target_path

    @property
    def target_mount_target_ext_id(self):
        """
        Target mount-target extId.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__target_mount_target_ext_id

    @target_mount_target_ext_id.setter
    def target_mount_target_ext_id(self, target_mount_target_ext_id):
        if target_mount_target_ext_id is None:
            raise ValueError("Invalid value for `target_mount_target_ext_id`, must not be `None`")  # noqa: E501
        if target_mount_target_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', target_mount_target_ext_id):  # noqa: E501
            raise ValueError(r"Invalid value for `target_mount_target_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__target_mount_target_ext_id = target_mount_target_ext_id

    @property
    def is_sync_type_mirror(self):
        """
        Indicates the flag for sync type. If false, then only the source will be synced. The delete and rename are not honored on the target, if anything is deleted or renamed on the source. If true, then the source will be mirrored on the target, that is, every delete and rename will be honored.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_sync_type_mirror

    @is_sync_type_mirror.setter
    def is_sync_type_mirror(self, is_sync_type_mirror):

        self.__is_sync_type_mirror = is_sync_type_mirror

    @property
    def status(self):
        """
        

        :type:
            :class:`~ntnx_files_py_client.models.files.v4.config.MigrationStatus`
        """  # noqa: E501
        return self.__status

    @status.setter
    def status(self, status):

        self.__status = status

    @property
    def status_msg(self):
        """
        Indicates the status message of the migration sub-plan. It updates after each migration step, informing the current migration sub-plan stage. This is a read-only field.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__status_msg

    @status_msg.setter
    def status_msg(self, status_msg):
        if status_msg is not None and len(status_msg) > 4096:
            raise ValueError("Invalid value for `status_msg`, length must be less than or equal to `4096`")  # noqa: E501

        self.__status_msg = status_msg

    @property
    def is_final_iteration(self):
        """
        A flag to identify if its final iteration. This flag should be given as true to do the final round of migration. It is recommended to keep the sub-plan source as readonly to migrate all the content from the source to the target. We prioritize such an iteration so that the read-only time for the source can be decreased by utilising migrator resources only for the subplans in final iteration. After the completion of this iteration, if no failed files are found, we need to update the sub-plan status as COMPLETED, and no further action on this sub-plan will be allowed. If there are failed files under max-limit while migration, the subplan status will be changed to succeded and you will have numberOfFilesFailed/numberOfDirectoriesFailed/numberOfStreamsFailed on migration job. These failed files name and error can be retrieved using GET failed-files-summary API, and upon error correction, the user can start another iteration to sync failed files only the flag shouldRetryOnlyFailedFiles flag.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_final_iteration

    @is_final_iteration.setter
    def is_final_iteration(self, is_final_iteration):

        self.__is_final_iteration = is_final_iteration

    @property
    def should_allow_unknown_sids(self):
        """
        A flag to indicate whether unknown SIDs should be allowed during migration instead of failing it.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_allow_unknown_sids

    @should_allow_unknown_sids.setter
    def should_allow_unknown_sids(self, should_allow_unknown_sids):

        self.__should_allow_unknown_sids = should_allow_unknown_sids

    @property
    def should_ignore_long_tld_names(self):
        """
        A flag to indicate whether long TLD name should be ignored while migration instead of failing it.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_ignore_long_tld_names

    @should_ignore_long_tld_names.setter
    def should_ignore_long_tld_names(self, should_ignore_long_tld_names):

        self.__should_ignore_long_tld_names = should_ignore_long_tld_names

    @property
    def should_ignore_files_at_root(self):
        """
        A flag to indicate whether files at root should be ignored while migration instead of failing it.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_ignore_files_at_root

    @should_ignore_files_at_root.setter
    def should_ignore_files_at_root(self, should_ignore_files_at_root):

        self.__should_ignore_files_at_root = should_ignore_files_at_root

    @property
    def should_retry_only_failed_files(self):
        """
        A flag to indicate whether the migration iteration is only to migrate failed files/directories from the last iteration. If it is false and status is changed to running from default, then the migration will start for the whole source mount target. If it is true, then only a list of failed files from the last iteration are retried for migration.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_retry_only_failed_files

    @should_retry_only_failed_files.setter
    def should_retry_only_failed_files(self, should_retry_only_failed_files):

        self.__should_retry_only_failed_files = should_retry_only_failed_files

    @property
    def protocol(self):
        """
        

        :type:
            :class:`~ntnx_files_py_client.models.files.v4.config.MountTargetProtocolType`
        """  # noqa: E501
        return self.__protocol

    @protocol.setter
    def protocol(self, protocol):

        self.__protocol = protocol

    def _to_dict(self, sanitize):
        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.

        :param sanitize: A flag to omit None properties if set to True
        :type sanitize: bool
        """

        result = {}
        for attr, attr_type in six.iteritems(self.swagger_types):

            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, Path):
                result[attr] = str(value)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
                    else (
                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
                        else item
                    ),
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(MigrationSubPlan, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        return result

    def to_dict(self):
        """Returns the model properties as a dictionary"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, MigrationSubPlan):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

