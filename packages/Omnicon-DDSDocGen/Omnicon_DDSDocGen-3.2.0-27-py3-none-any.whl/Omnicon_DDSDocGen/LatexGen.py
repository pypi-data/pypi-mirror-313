# Abstract Base class
import logging
import os

from DocGenInterface import DocGenInterface
import subprocess

import pylatex
from pylatex import PageStyle, Head, MiniPage, Foot, LargeText, \
    NewPage, HugeText, LineBreak, NewLine, simple_page_number, LongTable, Section, NoEscape, Package, Command
import pdf2docx

from pylatex.utils import bold
from pdflatex import PDFLaTeX
from datetime import datetime
import sys
from . import Logger

# constants
VER_NUM = "Ver1.0"


class LatexGen(DocGenInterface):
    def __init__(self, title: str, version: str, time: str, margin="0.7in", font="Arial", landscape=True):
        super().__init__(title, version, time)

        self.logger = Logger.add_logger(__name__)
        # geometry_options = {"margin": "0.7in", "landscape": True, }
        geometry_options = {"margin": margin, "landscape": landscape}
        self.doc = pylatex.Document(geometry_options=geometry_options, document_options=['hidelinks'])

        # this is for hyperlinks ref for table of contents
        self.doc.packages.append(Package('hyperref'))
        self.doc.packages.append(Package('adjustbox'))
        self.doc.packages.append(Package('booktabs'))
        self.doc.packages.append(Package('longtable'))
        self.doc.packages.append(Package('threeparttable'))
        self.doc.packages.append(Package('textcomp'))
        self.doc.packages.append(Package('array'))
        self.doc.packages.append(Package('seqsplit'))
        self.doc.packages.append(Package('xurl'))
        self.doc.packages.append(Package('tocloft'))

        try:
            # required in order to find the exe when packing with another exe using pyinstaller
            # https://stackoverflow.com/questions/14296833/pyinstaller-onefile-doesnt-find-data-files
            wd = sys._MEIPASS
        except AttributeError:
            wd = os.getcwd()
        self.pandoc_dir = os.path.join(wd, 'resources', 'pandoc', 'pandoc.exe')
        self.pdflatex_dir = os.path.join(wd, 'resources', 'pdflatex', 'pdflatex.exe')
        self.texify_dir = os.path.join(wd, 'resources', 'pdflatex', 'texify.exe')

        if font == "Arial":
            # Install Font Arial - Must be before all the rest in the pre-emble (header etc.)
            self.doc.preamble.append(NoEscape('\\renewcommand{\\familydefault}{\sfdefault}'))
            self.doc.preamble.append(NoEscape('\\renewcommand{\\rmdefault}{phv}'))

        # theDoc = LaTexDoc(font="TimesNewR")    #font="Arial" - def value
        self.add_doc_title_page(self.title)
        self.add_toc_page()
        self.add_new_page()

    def add_doc_title_page(self, title: str = "ICD", bTimeDate=True, bAligned='c'):
        """
        This function adds a title page, with creation time, including header & footer,
        to be appended as a preamble section.
        :param title: The title of the document.
        :param bTimeDate: Add time of creation.
        :param bAligned: Alignment l/c/r . default is centering.
        """
        self.logger.debug(self.add_doc_title_page.__name__)
        header = PageStyle("header", header_thickness=2, footer_thickness=1)

        # Insert this command for later usage of table of contents
        header.append(NoEscape('\\renewcommand{\contentsname}{Table Of Contents}'))

        # Create center header
        with header.create(Head("C")):
            header.append("Automatically Generated By OmnicCon DDS Document Generator Â©")

        # Create center footer
        with header.create(Foot("C")):
            header.append(simple_page_number())

        self.doc.preamble.append(header)
        self.doc.change_document_style("header")

        # Add creation date/time
        now: datetime = datetime.now()
        date_time_string: str = now.strftime("%d/%m/%Y %H:%M:%S")

        # Modify for vertical centering - start
        self.doc.append(Command(NoEscape("vspace*{\\fill}")))

        with self.doc.create(MiniPage(align=bAligned)):
            # self.doc.append(Command(NoEscape("fontsize{50}{60}\selectfont")))
            self.doc.append(HugeText(bold(title)))
            self.add_new_line()
            self.doc.append(LargeText(bold("Time of creation: " + date_time_string)))
            self.add_new_line()
            self.doc.append(LargeText(bold("Version: " + VER_NUM)))

        # Modify for vertical centering - end
        self.doc.append(Command(NoEscape("vspace*{\\fill}")))

    def add_toc_page(self):
        """
        This function adds a table of contents with hyperlink.
        :param NONE.
        """
        self.logger.debug(self.add_toc_page.__name__)
        self.doc.append(NewPage())
        self.doc.append(NoEscape('\centering'))
        self.doc.append(NoEscape(r"\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}"))
        self.doc.append(NoEscape('\\tableofcontents'))
        self.doc.append(NoEscape('\\flushleft'))

    def add_chapter(self, section_title, sub_section_title=""):
        """
        This function adds a new chapter, on a new page.
        :param section_title: section name.
        :param sub_section_title: sub section name.
        """
        self.logger.debug(self.add_chapter.__name__)
        self.doc.append(NewPage())
        with self.doc.create(Section(section_title)):
            self.doc.append(bold(sub_section_title))
            # self.add_new_line()
            #    pass

    def add_table_header(self, listOfTitles, bLongHeader=True, color="grey") -> LongTable:
        """
        This function creates a table, and adds a table header with the titles.
        It is a "long table" and header is duplicated on each pade, if table
        is long enough to continue beyong a single page..
        :param listOfTitles: the titles of the columns at the table header.
        :param bLongHeader: not in use, inherited from base class. May be needed in
                            other implementation environments. Defaults to True.
        :param color: the color of the table header, for better visualization.
                      Defaults to grey.
        """
        # https://tex.stackexchange.com/questions/355898/wrap-text-in-long-table-improvement-ideas
        # specification of the columns - positioning, width, alignment of text
        self.logger.debug(self.add_table_header.__name__)
        mystr = r'@{}' \
                r'|p{1.5cm}' \
                r'|p{4.5cm}' \
                r'|p{5.5cm}' \
                r'|p{9.5cm}|' \
                r'@{}'
        with self.doc.create(LongTable(mystr, pos=['l'])) as table:
            table.add_hline()  # horizontal line
            table.add_row(listOfTitles, color='lightgray', mapper=[bold])  # decorate with bold
            table.add_hline()
            self.doc.append(Command(NoEscape(r"endhead")))  # for header per page on long tables
            return table

    def add_table_row(self, theTable, cells_text, align='c'):  # align=centered
        """
        This function adds a row for a table.
        :param theTable: the table object.
        :param cells_text: the data for the columns - as text.
        :param color: alignment - centered (not in use here)
        """
        # https://tex.stackexchange.com/questions/490899/break-long-word-not-long-text-in-longtable-cell

        self.logger.debug(self.add_table_row.__name__)
        currTable: LongTable = theTable
        if (cells_text[0] == ""):
            # if cells_text[0] = "None":
            currTable.add_row(cells_text[0], bold(LaTexDoc.__seqsplit(cells_text[1])), cells_text[2],
                              cells_text[3])  # , mapper=[bold])
        else:
            currTable.add_row(cells_text[0], LaTexDoc.__seqsplit(cells_text[1]), cells_text[2], cells_text[3])

        currTable.add_hline()  # adds horizontal line after each row

    @staticmethod
    def __seqsplit(s, escape: bool = True):
        if escape:
            s = pylatex.utils.escape_latex(s)
        return NoEscape(r'\seqsplit{' + s + '}')

    def add_new_page(self):
        """
        This function adds a new page.
        :param No params.
        """
        self.logger.debug(self.add_new_page.__name__)
        self.doc.append(NewPage())

    def add_section(self):
        """
        This function adds a new section. Not implemented.
        :param No params.
        """
        self.logger.debug(self.add_section.__name__)
        pass

    def add_description(self, descr="default descr"):
        """
        This function adds a description (within a new section/subsection)..
        :param descr - the text.
        """
        self.logger.debug(self.add_description.__name__)
        with self.doc.create(MiniPage(align='l')):
            self.doc.append(Command(NoEscape(r"underline{Description}")))
            self.doc.append(": ")
            self.doc.append(descr)
            # self.add_new_line()

    def add_new_line(self):
        """
        This function adds a new line.
        :param None.
        """
        self.logger.debug(self.add_new_line.__name__)
        self.doc.append(LineBreak())
        self.doc.append(NewLine())

    def generate_doc(self, output_file_name, output_folder_name, temp_folder):
        """
        This function invokes the generation of the LaTex file.

        """
        self.logger.debug(self.generate_doc.__name__)

        combined_file_and_folder = os.path.join(output_folder_name, output_file_name)
        try:
            self.doc.generate_tex(combined_file_and_folder)
        except Exception as e:
            logging.error("generate tex file failed {}".format(str(e)))

        try:
            texify_exe = subprocess.Popen(
                [self.texify_dir, '--pdf', '--synctex=1', '--clean', combined_file_and_folder + ".tex"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output, errors = texify_exe.communicate()
            logging.info(output.decode('utf-8'))

            if texify_exe.returncode != 0:
                logging.error('latex to pdf failed failed {}'.format(str(texify_exe.returncode)))
            else:
                logging.info('latex to pdf completed')
        except Exception as e:
            logging.error("generate pdf failed {}".format(str(e)))

        return

        # try:
        # #pdf latex method
        #     pdflatex_exe = subprocess.Popen(
        #         [self.pdflatex_dir, combined_file_and_folder + ".tex"],
        #         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        #     output, errors = pdflatex_exe.communicate()
        #     logging.info(output.decode('utf-8'))
        #
        #     if pdflatex_exe.returncode != 0:
        #         logging.error('latex to pdf failed failed {}'.format(str(pdflatex_exe.returncode)))
        #     else:
        #         logging.info('latex to pdf completed')
        # except Exception as e:
        #     logging.error("generate pdf failed {}".format(str(e)))

        try:
            # TODO decide how to generate the docx

            # import glob
            # import win32com.client
            # import os
            #
            # word = win32com.client.Dispatch("Word.Application")
            # word.visible = 0
            #
            # pdfs_path = ""  # folder where the .pdf files are stored
            # for i, doc in enumerate(glob.iglob(pdfs_path + "*.pdf")):
            #     print(doc)
            #     filename = doc.split('\\')[-1]
            #     in_file = os.path.abspath(doc)
            #     print(in_file)
            #     wb = word.Documents.Open(in_file)
            #     out_file = os.path.abspath(combined_file_and_folder + ".docx".format(i))
            #     print("outfile\n", out_file)
            #     wb.SaveAs2(out_file, FileFormat=16)  # file format for docx
            #     print("success...")
            #     wb.Close()
            #
            # word.Quit()

            cv = pdf2docx.Converter(combined_file_and_folder + '.pdf')
            cv.convert(combined_file_and_folder + '.docx', start=0, end=None)
            cv.close()

            pandoc_exe = subprocess.Popen(
                [self.pandoc_dir, combined_file_and_folder + ".tex", '-o', combined_file_and_folder + ".docx"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output, errors = pandoc_exe.communicate()
            logging.info(output.decode('utf-8'))

            if pandoc_exe.returncode != 0:
                logging.error('latex to docx failed failed {}'.format(str(pandoc_exe.returncode)))
            else:
                logging.info('latex to docx completed')
        except Exception as e:
            logging.error("generate docx failed {}".format(str(e)))