"""A web3.py Contract class for the Errors contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.48.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    PypechainBaseContractErrors,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3.contract.contract import (
    Contract,
    ContractConstructor,
    ContractFunctions,
)
from web3.types import BlockIdentifier, StateOverride, TxParams

structs = {}

errors_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "ACL_ADMIN_CANNOT_BE_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "ADDRESSES_PROVIDER_ALREADY_ADDED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "ADDRESSES_PROVIDER_NOT_REGISTERED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "ASSET_NOT_BORROWABLE_IN_ISOLATION",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "ASSET_NOT_LISTED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "BORROWING_NOT_ENABLED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "BORROW_CAP_EXCEEDED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "BRIDGE_PROTOCOL_FEE_INVALID",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_MUST_BE_POOL",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_ATOKEN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_BRIDGE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_EMERGENCY_ADMIN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_POOL_ADMIN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_POOL_CONFIGURATOR",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_POOL_OR_EMERGENCY_ADMIN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_RISK_OR_POOL_ADMIN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "COLLATERAL_BALANCE_IS_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "COLLATERAL_CANNOT_BE_LIQUIDATED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "COLLATERAL_CANNOT_COVER_NEW_BORROW",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "COLLATERAL_SAME_AS_BORROWING_CURRENCY",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "DEBT_CEILING_EXCEEDED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "DEBT_CEILING_NOT_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "EMODE_CATEGORY_RESERVED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_DISABLED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FLASHLOAN_PREMIUM_INVALID",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "HEALTH_FACTOR_NOT_BELOW_THRESHOLD",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INCONSISTENT_EMODE_CATEGORY",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INCONSISTENT_FLASHLOAN_PARAMS",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INCONSISTENT_PARAMS_LENGTH",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_ADDRESSES_PROVIDER",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_ADDRESSES_PROVIDER_ID",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_AMOUNT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_BORROW_CAP",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_BURN_AMOUNT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_DEBT_CEILING",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_DECIMALS",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_EMODE_CATEGORY",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_EMODE_CATEGORY_ASSIGNMENT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_EMODE_CATEGORY_PARAMS",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_EXPIRATION",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_FLASHLOAN_EXECUTOR_RETURN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_FREEZE_STATE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_GRACE_PERIOD",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_INTEREST_RATE_MODE_SELECTED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_LIQUIDATION_PROTOCOL_FEE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_LIQ_BONUS",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_LIQ_THRESHOLD",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_LTV",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_MAX_RATE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_MINT_AMOUNT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_OPTIMAL_USAGE_RATIO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_RESERVE_FACTOR",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_RESERVE_INDEX",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_RESERVE_PARAMS",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_SIGNATURE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_SUPPLY_CAP",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "INVALID_UNBACKED_MINT_CAP",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "LTV_VALIDATION_FAILED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "NOT_CONTRACT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "NOT_ENOUGH_AVAILABLE_USER_BALANCE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "NO_DEBT_OF_SELECTED_TYPE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "NO_MORE_RESERVES_ALLOWED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "NO_OUTSTANDING_STABLE_DEBT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "NO_OUTSTANDING_VARIABLE_DEBT",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "OPERATION_NOT_SUPPORTED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "POOL_ADDRESSES_DO_NOT_MATCH",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "PRICE_ORACLE_SENTINEL_CHECK_FAILED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "RESERVE_ALREADY_ADDED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "RESERVE_ALREADY_INITIALIZED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "RESERVE_DEBT_NOT_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "RESERVE_FROZEN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "RESERVE_INACTIVE",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "RESERVE_LIQUIDITY_NOT_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "RESERVE_PAUSED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "SILOED_BORROWING_VIOLATION",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "SLOPE_2_MUST_BE_GTE_SLOPE_1",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "STABLE_BORROWING_ENABLED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "STABLE_BORROWING_NOT_ENABLED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "STABLE_DEBT_NOT_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "SUPPLY_CAP_EXCEEDED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "SUPPLY_TO_ATOKEN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "UNBACKED_MINT_CAP_EXCEEDED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "UNDERLYING_BALANCE_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "UNDERLYING_CANNOT_BE_RESCUED",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "USER_IN_ISOLATION_MODE_OR_LTV_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "VARIABLE_DEBT_SUPPLY_NOT_ZERO",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "WITHDRAW_TO_ATOKEN",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "ZERO_ADDRESS_NOT_VALID",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "string", "internalType": "string"}
            ],
            "stateMutability": "view",
        },
    ],
)


class ErrorsContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the Errors contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class ErrorsACL_ADMIN_CANNOT_BE_ZEROContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the ACL_ADMIN_CANNOT_BE_ZERO() method."""

    _function_name = "ACL_ADMIN_CANNOT_BE_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsACL_ADMIN_CANNOT_BE_ZEROContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the ACL_ADMIN_CANNOT_BE_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ACL_ADMIN_CANNOT_BE_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsACL_ADMIN_CANNOT_BE_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsACL_ADMIN_CANNOT_BE_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsACL_ADMIN_CANNOT_BE_ZEROContractFunction0._type_signature: ErrorsACL_ADMIN_CANNOT_BE_ZEROContractFunction0,
        }
        return out


class ErrorsADDRESSES_PROVIDER_ALREADY_ADDEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the ADDRESSES_PROVIDER_ALREADY_ADDED() method."""

    _function_name = "ADDRESSES_PROVIDER_ALREADY_ADDED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsADDRESSES_PROVIDER_ALREADY_ADDEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the ADDRESSES_PROVIDER_ALREADY_ADDED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ADDRESSES_PROVIDER_ALREADY_ADDED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsADDRESSES_PROVIDER_ALREADY_ADDEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsADDRESSES_PROVIDER_ALREADY_ADDEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsADDRESSES_PROVIDER_ALREADY_ADDEDContractFunction0._type_signature: ErrorsADDRESSES_PROVIDER_ALREADY_ADDEDContractFunction0,
        }
        return out


class ErrorsADDRESSES_PROVIDER_NOT_REGISTEREDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the ADDRESSES_PROVIDER_NOT_REGISTERED() method."""

    _function_name = "ADDRESSES_PROVIDER_NOT_REGISTERED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsADDRESSES_PROVIDER_NOT_REGISTEREDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the ADDRESSES_PROVIDER_NOT_REGISTERED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ADDRESSES_PROVIDER_NOT_REGISTERED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsADDRESSES_PROVIDER_NOT_REGISTEREDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsADDRESSES_PROVIDER_NOT_REGISTEREDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsADDRESSES_PROVIDER_NOT_REGISTEREDContractFunction0._type_signature: ErrorsADDRESSES_PROVIDER_NOT_REGISTEREDContractFunction0,
        }
        return out


class ErrorsAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLEContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE() method."""

    _function_name = "AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLEContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLEContractFunction0._type_signature: ErrorsAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLEContractFunction0,
        }
        return out


class ErrorsASSET_NOT_BORROWABLE_IN_ISOLATIONContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the ASSET_NOT_BORROWABLE_IN_ISOLATION() method."""

    _function_name = "ASSET_NOT_BORROWABLE_IN_ISOLATION"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsASSET_NOT_BORROWABLE_IN_ISOLATIONContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the ASSET_NOT_BORROWABLE_IN_ISOLATION method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ASSET_NOT_BORROWABLE_IN_ISOLATION"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsASSET_NOT_BORROWABLE_IN_ISOLATIONContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsASSET_NOT_BORROWABLE_IN_ISOLATIONContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsASSET_NOT_BORROWABLE_IN_ISOLATIONContractFunction0._type_signature: ErrorsASSET_NOT_BORROWABLE_IN_ISOLATIONContractFunction0,
        }
        return out


class ErrorsASSET_NOT_LISTEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the ASSET_NOT_LISTED() method."""

    _function_name = "ASSET_NOT_LISTED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsASSET_NOT_LISTEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the ASSET_NOT_LISTED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ASSET_NOT_LISTED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsASSET_NOT_LISTEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsASSET_NOT_LISTEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsASSET_NOT_LISTEDContractFunction0._type_signature: ErrorsASSET_NOT_LISTEDContractFunction0,
        }
        return out


class ErrorsBORROWING_NOT_ENABLEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the BORROWING_NOT_ENABLED() method."""

    _function_name = "BORROWING_NOT_ENABLED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsBORROWING_NOT_ENABLEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the BORROWING_NOT_ENABLED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "BORROWING_NOT_ENABLED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsBORROWING_NOT_ENABLEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsBORROWING_NOT_ENABLEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsBORROWING_NOT_ENABLEDContractFunction0._type_signature: ErrorsBORROWING_NOT_ENABLEDContractFunction0,
        }
        return out


class ErrorsBORROW_CAP_EXCEEDEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the BORROW_CAP_EXCEEDED() method."""

    _function_name = "BORROW_CAP_EXCEEDED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsBORROW_CAP_EXCEEDEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the BORROW_CAP_EXCEEDED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "BORROW_CAP_EXCEEDED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsBORROW_CAP_EXCEEDEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsBORROW_CAP_EXCEEDEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsBORROW_CAP_EXCEEDEDContractFunction0._type_signature: ErrorsBORROW_CAP_EXCEEDEDContractFunction0,
        }
        return out


class ErrorsBRIDGE_PROTOCOL_FEE_INVALIDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE_INVALID() method."""

    _function_name = "BRIDGE_PROTOCOL_FEE_INVALID"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsBRIDGE_PROTOCOL_FEE_INVALIDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the BRIDGE_PROTOCOL_FEE_INVALID method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "BRIDGE_PROTOCOL_FEE_INVALID"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsBRIDGE_PROTOCOL_FEE_INVALIDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsBRIDGE_PROTOCOL_FEE_INVALIDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsBRIDGE_PROTOCOL_FEE_INVALIDContractFunction0._type_signature: ErrorsBRIDGE_PROTOCOL_FEE_INVALIDContractFunction0,
        }
        return out


class ErrorsCALLER_MUST_BE_POOLContractFunction0(PypechainContractFunction):
    """ContractFunction for the CALLER_MUST_BE_POOL() method."""

    _function_name = "CALLER_MUST_BE_POOL"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_MUST_BE_POOLContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the CALLER_MUST_BE_POOL method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_MUST_BE_POOL"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_MUST_BE_POOLContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_MUST_BE_POOLContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_MUST_BE_POOLContractFunction0._type_signature: ErrorsCALLER_MUST_BE_POOLContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_ASSET_LISTING_OR_POOL_ADMINContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN() method."""

    _function_name = "CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_ASSET_LISTING_OR_POOL_ADMINContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_ASSET_LISTING_OR_POOL_ADMINContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_ASSET_LISTING_OR_POOL_ADMINContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_ASSET_LISTING_OR_POOL_ADMINContractFunction0._type_signature: ErrorsCALLER_NOT_ASSET_LISTING_OR_POOL_ADMINContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_ATOKENContractFunction0(PypechainContractFunction):
    """ContractFunction for the CALLER_NOT_ATOKEN() method."""

    _function_name = "CALLER_NOT_ATOKEN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_ATOKENContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the CALLER_NOT_ATOKEN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_ATOKEN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_ATOKENContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_ATOKENContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_ATOKENContractFunction0._type_signature: ErrorsCALLER_NOT_ATOKENContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_BRIDGEContractFunction0(PypechainContractFunction):
    """ContractFunction for the CALLER_NOT_BRIDGE() method."""

    _function_name = "CALLER_NOT_BRIDGE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_BRIDGEContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the CALLER_NOT_BRIDGE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_BRIDGE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_BRIDGEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_BRIDGEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_BRIDGEContractFunction0._type_signature: ErrorsCALLER_NOT_BRIDGEContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_EMERGENCY_ADMINContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the CALLER_NOT_EMERGENCY_ADMIN() method."""

    _function_name = "CALLER_NOT_EMERGENCY_ADMIN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_EMERGENCY_ADMINContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the CALLER_NOT_EMERGENCY_ADMIN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_EMERGENCY_ADMIN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_EMERGENCY_ADMINContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_EMERGENCY_ADMINContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_EMERGENCY_ADMINContractFunction0._type_signature: ErrorsCALLER_NOT_EMERGENCY_ADMINContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_POOL_ADMINContractFunction0(PypechainContractFunction):
    """ContractFunction for the CALLER_NOT_POOL_ADMIN() method."""

    _function_name = "CALLER_NOT_POOL_ADMIN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_POOL_ADMINContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the CALLER_NOT_POOL_ADMIN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_POOL_ADMIN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_POOL_ADMINContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_POOL_ADMINContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_POOL_ADMINContractFunction0._type_signature: ErrorsCALLER_NOT_POOL_ADMINContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_POOL_CONFIGURATORContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the CALLER_NOT_POOL_CONFIGURATOR() method."""

    _function_name = "CALLER_NOT_POOL_CONFIGURATOR"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_POOL_CONFIGURATORContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the CALLER_NOT_POOL_CONFIGURATOR method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_POOL_CONFIGURATOR"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_POOL_CONFIGURATORContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_POOL_CONFIGURATORContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_POOL_CONFIGURATORContractFunction0._type_signature: ErrorsCALLER_NOT_POOL_CONFIGURATORContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_POOL_OR_EMERGENCY_ADMINContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the CALLER_NOT_POOL_OR_EMERGENCY_ADMIN() method."""

    _function_name = "CALLER_NOT_POOL_OR_EMERGENCY_ADMIN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_POOL_OR_EMERGENCY_ADMINContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the CALLER_NOT_POOL_OR_EMERGENCY_ADMIN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_POOL_OR_EMERGENCY_ADMIN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_POOL_OR_EMERGENCY_ADMINContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_POOL_OR_EMERGENCY_ADMINContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_POOL_OR_EMERGENCY_ADMINContractFunction0._type_signature: ErrorsCALLER_NOT_POOL_OR_EMERGENCY_ADMINContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_RISK_OR_POOL_ADMINContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the CALLER_NOT_RISK_OR_POOL_ADMIN() method."""

    _function_name = "CALLER_NOT_RISK_OR_POOL_ADMIN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_RISK_OR_POOL_ADMINContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the CALLER_NOT_RISK_OR_POOL_ADMIN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_RISK_OR_POOL_ADMIN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_RISK_OR_POOL_ADMINContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_RISK_OR_POOL_ADMINContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_RISK_OR_POOL_ADMINContractFunction0._type_signature: ErrorsCALLER_NOT_RISK_OR_POOL_ADMINContractFunction0,
        }
        return out


class ErrorsCALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMINContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN() method."""

    _function_name = "CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMINContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMINContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMINContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMINContractFunction0._type_signature: ErrorsCALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMINContractFunction0,
        }
        return out


class ErrorsCOLLATERAL_BALANCE_IS_ZEROContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the COLLATERAL_BALANCE_IS_ZERO() method."""

    _function_name = "COLLATERAL_BALANCE_IS_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCOLLATERAL_BALANCE_IS_ZEROContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the COLLATERAL_BALANCE_IS_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "COLLATERAL_BALANCE_IS_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCOLLATERAL_BALANCE_IS_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCOLLATERAL_BALANCE_IS_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCOLLATERAL_BALANCE_IS_ZEROContractFunction0._type_signature: ErrorsCOLLATERAL_BALANCE_IS_ZEROContractFunction0,
        }
        return out


class ErrorsCOLLATERAL_CANNOT_BE_LIQUIDATEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the COLLATERAL_CANNOT_BE_LIQUIDATED() method."""

    _function_name = "COLLATERAL_CANNOT_BE_LIQUIDATED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCOLLATERAL_CANNOT_BE_LIQUIDATEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the COLLATERAL_CANNOT_BE_LIQUIDATED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "COLLATERAL_CANNOT_BE_LIQUIDATED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCOLLATERAL_CANNOT_BE_LIQUIDATEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCOLLATERAL_CANNOT_BE_LIQUIDATEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCOLLATERAL_CANNOT_BE_LIQUIDATEDContractFunction0._type_signature: ErrorsCOLLATERAL_CANNOT_BE_LIQUIDATEDContractFunction0,
        }
        return out


class ErrorsCOLLATERAL_CANNOT_COVER_NEW_BORROWContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the COLLATERAL_CANNOT_COVER_NEW_BORROW() method."""

    _function_name = "COLLATERAL_CANNOT_COVER_NEW_BORROW"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCOLLATERAL_CANNOT_COVER_NEW_BORROWContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the COLLATERAL_CANNOT_COVER_NEW_BORROW method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "COLLATERAL_CANNOT_COVER_NEW_BORROW"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCOLLATERAL_CANNOT_COVER_NEW_BORROWContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCOLLATERAL_CANNOT_COVER_NEW_BORROWContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCOLLATERAL_CANNOT_COVER_NEW_BORROWContractFunction0._type_signature: ErrorsCOLLATERAL_CANNOT_COVER_NEW_BORROWContractFunction0,
        }
        return out


class ErrorsCOLLATERAL_SAME_AS_BORROWING_CURRENCYContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the COLLATERAL_SAME_AS_BORROWING_CURRENCY() method."""

    _function_name = "COLLATERAL_SAME_AS_BORROWING_CURRENCY"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsCOLLATERAL_SAME_AS_BORROWING_CURRENCYContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the COLLATERAL_SAME_AS_BORROWING_CURRENCY method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "COLLATERAL_SAME_AS_BORROWING_CURRENCY"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsCOLLATERAL_SAME_AS_BORROWING_CURRENCYContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsCOLLATERAL_SAME_AS_BORROWING_CURRENCYContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsCOLLATERAL_SAME_AS_BORROWING_CURRENCYContractFunction0._type_signature: ErrorsCOLLATERAL_SAME_AS_BORROWING_CURRENCYContractFunction0,
        }
        return out


class ErrorsDEBT_CEILING_EXCEEDEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the DEBT_CEILING_EXCEEDED() method."""

    _function_name = "DEBT_CEILING_EXCEEDED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsDEBT_CEILING_EXCEEDEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the DEBT_CEILING_EXCEEDED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "DEBT_CEILING_EXCEEDED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsDEBT_CEILING_EXCEEDEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsDEBT_CEILING_EXCEEDEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsDEBT_CEILING_EXCEEDEDContractFunction0._type_signature: ErrorsDEBT_CEILING_EXCEEDEDContractFunction0,
        }
        return out


class ErrorsDEBT_CEILING_NOT_ZEROContractFunction0(PypechainContractFunction):
    """ContractFunction for the DEBT_CEILING_NOT_ZERO() method."""

    _function_name = "DEBT_CEILING_NOT_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsDEBT_CEILING_NOT_ZEROContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the DEBT_CEILING_NOT_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "DEBT_CEILING_NOT_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsDEBT_CEILING_NOT_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsDEBT_CEILING_NOT_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsDEBT_CEILING_NOT_ZEROContractFunction0._type_signature: ErrorsDEBT_CEILING_NOT_ZEROContractFunction0,
        }
        return out


class ErrorsEMODE_CATEGORY_RESERVEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the EMODE_CATEGORY_RESERVED() method."""

    _function_name = "EMODE_CATEGORY_RESERVED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsEMODE_CATEGORY_RESERVEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the EMODE_CATEGORY_RESERVED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "EMODE_CATEGORY_RESERVED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsEMODE_CATEGORY_RESERVEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsEMODE_CATEGORY_RESERVEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsEMODE_CATEGORY_RESERVEDContractFunction0._type_signature: ErrorsEMODE_CATEGORY_RESERVEDContractFunction0,
        }
        return out


class ErrorsFLASHLOAN_DISABLEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the FLASHLOAN_DISABLED() method."""

    _function_name = "FLASHLOAN_DISABLED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsFLASHLOAN_DISABLEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the FLASHLOAN_DISABLED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FLASHLOAN_DISABLED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsFLASHLOAN_DISABLEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsFLASHLOAN_DISABLEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsFLASHLOAN_DISABLEDContractFunction0._type_signature: ErrorsFLASHLOAN_DISABLEDContractFunction0,
        }
        return out


class ErrorsFLASHLOAN_PREMIUM_INVALIDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the FLASHLOAN_PREMIUM_INVALID() method."""

    _function_name = "FLASHLOAN_PREMIUM_INVALID"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsFLASHLOAN_PREMIUM_INVALIDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the FLASHLOAN_PREMIUM_INVALID method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FLASHLOAN_PREMIUM_INVALID"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsFLASHLOAN_PREMIUM_INVALIDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsFLASHLOAN_PREMIUM_INVALIDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsFLASHLOAN_PREMIUM_INVALIDContractFunction0._type_signature: ErrorsFLASHLOAN_PREMIUM_INVALIDContractFunction0,
        }
        return out


class ErrorsHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD() method."""

    _function_name = "HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLDContractFunction0._type_signature: ErrorsHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLDContractFunction0,
        }
        return out


class ErrorsHEALTH_FACTOR_NOT_BELOW_THRESHOLDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the HEALTH_FACTOR_NOT_BELOW_THRESHOLD() method."""

    _function_name = "HEALTH_FACTOR_NOT_BELOW_THRESHOLD"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsHEALTH_FACTOR_NOT_BELOW_THRESHOLDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the HEALTH_FACTOR_NOT_BELOW_THRESHOLD method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "HEALTH_FACTOR_NOT_BELOW_THRESHOLD"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsHEALTH_FACTOR_NOT_BELOW_THRESHOLDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsHEALTH_FACTOR_NOT_BELOW_THRESHOLDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsHEALTH_FACTOR_NOT_BELOW_THRESHOLDContractFunction0._type_signature: ErrorsHEALTH_FACTOR_NOT_BELOW_THRESHOLDContractFunction0,
        }
        return out


class ErrorsINCONSISTENT_EMODE_CATEGORYContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INCONSISTENT_EMODE_CATEGORY() method."""

    _function_name = "INCONSISTENT_EMODE_CATEGORY"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINCONSISTENT_EMODE_CATEGORYContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INCONSISTENT_EMODE_CATEGORY method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INCONSISTENT_EMODE_CATEGORY"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINCONSISTENT_EMODE_CATEGORYContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINCONSISTENT_EMODE_CATEGORYContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINCONSISTENT_EMODE_CATEGORYContractFunction0._type_signature: ErrorsINCONSISTENT_EMODE_CATEGORYContractFunction0,
        }
        return out


class ErrorsINCONSISTENT_FLASHLOAN_PARAMSContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INCONSISTENT_FLASHLOAN_PARAMS() method."""

    _function_name = "INCONSISTENT_FLASHLOAN_PARAMS"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINCONSISTENT_FLASHLOAN_PARAMSContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INCONSISTENT_FLASHLOAN_PARAMS method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INCONSISTENT_FLASHLOAN_PARAMS"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINCONSISTENT_FLASHLOAN_PARAMSContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINCONSISTENT_FLASHLOAN_PARAMSContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINCONSISTENT_FLASHLOAN_PARAMSContractFunction0._type_signature: ErrorsINCONSISTENT_FLASHLOAN_PARAMSContractFunction0,
        }
        return out


class ErrorsINCONSISTENT_PARAMS_LENGTHContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INCONSISTENT_PARAMS_LENGTH() method."""

    _function_name = "INCONSISTENT_PARAMS_LENGTH"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINCONSISTENT_PARAMS_LENGTHContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INCONSISTENT_PARAMS_LENGTH method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INCONSISTENT_PARAMS_LENGTH"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINCONSISTENT_PARAMS_LENGTHContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINCONSISTENT_PARAMS_LENGTHContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINCONSISTENT_PARAMS_LENGTHContractFunction0._type_signature: ErrorsINCONSISTENT_PARAMS_LENGTHContractFunction0,
        }
        return out


class ErrorsINTEREST_RATE_REBALANCE_CONDITIONS_NOT_METContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET() method."""

    _function_name = "INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINTEREST_RATE_REBALANCE_CONDITIONS_NOT_METContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINTEREST_RATE_REBALANCE_CONDITIONS_NOT_METContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINTEREST_RATE_REBALANCE_CONDITIONS_NOT_METContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINTEREST_RATE_REBALANCE_CONDITIONS_NOT_METContractFunction0._type_signature: ErrorsINTEREST_RATE_REBALANCE_CONDITIONS_NOT_METContractFunction0,
        }
        return out


class ErrorsINVALID_ADDRESSES_PROVIDERContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_ADDRESSES_PROVIDER() method."""

    _function_name = "INVALID_ADDRESSES_PROVIDER"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_ADDRESSES_PROVIDERContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_ADDRESSES_PROVIDER method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_ADDRESSES_PROVIDER"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_ADDRESSES_PROVIDERContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_ADDRESSES_PROVIDERContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_ADDRESSES_PROVIDERContractFunction0._type_signature: ErrorsINVALID_ADDRESSES_PROVIDERContractFunction0,
        }
        return out


class ErrorsINVALID_ADDRESSES_PROVIDER_IDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_ADDRESSES_PROVIDER_ID() method."""

    _function_name = "INVALID_ADDRESSES_PROVIDER_ID"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_ADDRESSES_PROVIDER_IDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_ADDRESSES_PROVIDER_ID method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_ADDRESSES_PROVIDER_ID"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_ADDRESSES_PROVIDER_IDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_ADDRESSES_PROVIDER_IDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_ADDRESSES_PROVIDER_IDContractFunction0._type_signature: ErrorsINVALID_ADDRESSES_PROVIDER_IDContractFunction0,
        }
        return out


class ErrorsINVALID_AMOUNTContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_AMOUNT() method."""

    _function_name = "INVALID_AMOUNT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_AMOUNTContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_AMOUNT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_AMOUNT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_AMOUNTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_AMOUNTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_AMOUNTContractFunction0._type_signature: ErrorsINVALID_AMOUNTContractFunction0,
        }
        return out


class ErrorsINVALID_BORROW_CAPContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_BORROW_CAP() method."""

    _function_name = "INVALID_BORROW_CAP"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_BORROW_CAPContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_BORROW_CAP method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_BORROW_CAP"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_BORROW_CAPContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_BORROW_CAPContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_BORROW_CAPContractFunction0._type_signature: ErrorsINVALID_BORROW_CAPContractFunction0,
        }
        return out


class ErrorsINVALID_BURN_AMOUNTContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_BURN_AMOUNT() method."""

    _function_name = "INVALID_BURN_AMOUNT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_BURN_AMOUNTContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_BURN_AMOUNT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_BURN_AMOUNT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_BURN_AMOUNTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_BURN_AMOUNTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_BURN_AMOUNTContractFunction0._type_signature: ErrorsINVALID_BURN_AMOUNTContractFunction0,
        }
        return out


class ErrorsINVALID_DEBT_CEILINGContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_DEBT_CEILING() method."""

    _function_name = "INVALID_DEBT_CEILING"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_DEBT_CEILINGContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_DEBT_CEILING method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_DEBT_CEILING"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_DEBT_CEILINGContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_DEBT_CEILINGContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_DEBT_CEILINGContractFunction0._type_signature: ErrorsINVALID_DEBT_CEILINGContractFunction0,
        }
        return out


class ErrorsINVALID_DECIMALSContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_DECIMALS() method."""

    _function_name = "INVALID_DECIMALS"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_DECIMALSContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_DECIMALS method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_DECIMALS"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_DECIMALSContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_DECIMALSContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_DECIMALSContractFunction0._type_signature: ErrorsINVALID_DECIMALSContractFunction0,
        }
        return out


class ErrorsINVALID_EMODE_CATEGORYContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_EMODE_CATEGORY() method."""

    _function_name = "INVALID_EMODE_CATEGORY"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_EMODE_CATEGORYContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_EMODE_CATEGORY method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_EMODE_CATEGORY"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_EMODE_CATEGORYContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_EMODE_CATEGORYContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_EMODE_CATEGORYContractFunction0._type_signature: ErrorsINVALID_EMODE_CATEGORYContractFunction0,
        }
        return out


class ErrorsINVALID_EMODE_CATEGORY_ASSIGNMENTContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_EMODE_CATEGORY_ASSIGNMENT() method."""

    _function_name = "INVALID_EMODE_CATEGORY_ASSIGNMENT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_EMODE_CATEGORY_ASSIGNMENTContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_EMODE_CATEGORY_ASSIGNMENT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_EMODE_CATEGORY_ASSIGNMENT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_EMODE_CATEGORY_ASSIGNMENTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_EMODE_CATEGORY_ASSIGNMENTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_EMODE_CATEGORY_ASSIGNMENTContractFunction0._type_signature: ErrorsINVALID_EMODE_CATEGORY_ASSIGNMENTContractFunction0,
        }
        return out


class ErrorsINVALID_EMODE_CATEGORY_PARAMSContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_EMODE_CATEGORY_PARAMS() method."""

    _function_name = "INVALID_EMODE_CATEGORY_PARAMS"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_EMODE_CATEGORY_PARAMSContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_EMODE_CATEGORY_PARAMS method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_EMODE_CATEGORY_PARAMS"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_EMODE_CATEGORY_PARAMSContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_EMODE_CATEGORY_PARAMSContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_EMODE_CATEGORY_PARAMSContractFunction0._type_signature: ErrorsINVALID_EMODE_CATEGORY_PARAMSContractFunction0,
        }
        return out


class ErrorsINVALID_EXPIRATIONContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_EXPIRATION() method."""

    _function_name = "INVALID_EXPIRATION"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_EXPIRATIONContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_EXPIRATION method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_EXPIRATION"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_EXPIRATIONContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_EXPIRATIONContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_EXPIRATIONContractFunction0._type_signature: ErrorsINVALID_EXPIRATIONContractFunction0,
        }
        return out


class ErrorsINVALID_FLASHLOAN_EXECUTOR_RETURNContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_FLASHLOAN_EXECUTOR_RETURN() method."""

    _function_name = "INVALID_FLASHLOAN_EXECUTOR_RETURN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_FLASHLOAN_EXECUTOR_RETURNContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_FLASHLOAN_EXECUTOR_RETURN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_FLASHLOAN_EXECUTOR_RETURN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_FLASHLOAN_EXECUTOR_RETURNContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_FLASHLOAN_EXECUTOR_RETURNContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_FLASHLOAN_EXECUTOR_RETURNContractFunction0._type_signature: ErrorsINVALID_FLASHLOAN_EXECUTOR_RETURNContractFunction0,
        }
        return out


class ErrorsINVALID_FREEZE_STATEContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_FREEZE_STATE() method."""

    _function_name = "INVALID_FREEZE_STATE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_FREEZE_STATEContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_FREEZE_STATE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_FREEZE_STATE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_FREEZE_STATEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_FREEZE_STATEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_FREEZE_STATEContractFunction0._type_signature: ErrorsINVALID_FREEZE_STATEContractFunction0,
        }
        return out


class ErrorsINVALID_GRACE_PERIODContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_GRACE_PERIOD() method."""

    _function_name = "INVALID_GRACE_PERIOD"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_GRACE_PERIODContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_GRACE_PERIOD method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_GRACE_PERIOD"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_GRACE_PERIODContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_GRACE_PERIODContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_GRACE_PERIODContractFunction0._type_signature: ErrorsINVALID_GRACE_PERIODContractFunction0,
        }
        return out


class ErrorsINVALID_INTEREST_RATE_MODE_SELECTEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_INTEREST_RATE_MODE_SELECTED() method."""

    _function_name = "INVALID_INTEREST_RATE_MODE_SELECTED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_INTEREST_RATE_MODE_SELECTEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_INTEREST_RATE_MODE_SELECTED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_INTEREST_RATE_MODE_SELECTED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_INTEREST_RATE_MODE_SELECTEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_INTEREST_RATE_MODE_SELECTEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_INTEREST_RATE_MODE_SELECTEDContractFunction0._type_signature: ErrorsINVALID_INTEREST_RATE_MODE_SELECTEDContractFunction0,
        }
        return out


class ErrorsINVALID_LIQUIDATION_PROTOCOL_FEEContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_LIQUIDATION_PROTOCOL_FEE() method."""

    _function_name = "INVALID_LIQUIDATION_PROTOCOL_FEE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_LIQUIDATION_PROTOCOL_FEEContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_LIQUIDATION_PROTOCOL_FEE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_LIQUIDATION_PROTOCOL_FEE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_LIQUIDATION_PROTOCOL_FEEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_LIQUIDATION_PROTOCOL_FEEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_LIQUIDATION_PROTOCOL_FEEContractFunction0._type_signature: ErrorsINVALID_LIQUIDATION_PROTOCOL_FEEContractFunction0,
        }
        return out


class ErrorsINVALID_LIQ_BONUSContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_LIQ_BONUS() method."""

    _function_name = "INVALID_LIQ_BONUS"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_LIQ_BONUSContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_LIQ_BONUS method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_LIQ_BONUS"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_LIQ_BONUSContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_LIQ_BONUSContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_LIQ_BONUSContractFunction0._type_signature: ErrorsINVALID_LIQ_BONUSContractFunction0,
        }
        return out


class ErrorsINVALID_LIQ_THRESHOLDContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_LIQ_THRESHOLD() method."""

    _function_name = "INVALID_LIQ_THRESHOLD"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_LIQ_THRESHOLDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_LIQ_THRESHOLD method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_LIQ_THRESHOLD"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_LIQ_THRESHOLDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_LIQ_THRESHOLDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_LIQ_THRESHOLDContractFunction0._type_signature: ErrorsINVALID_LIQ_THRESHOLDContractFunction0,
        }
        return out


class ErrorsINVALID_LTVContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_LTV() method."""

    _function_name = "INVALID_LTV"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_LTVContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_LTV method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_LTV"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_LTVContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_LTVContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_LTVContractFunction0._type_signature: ErrorsINVALID_LTVContractFunction0,
        }
        return out


class ErrorsINVALID_MAX_RATEContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_MAX_RATE() method."""

    _function_name = "INVALID_MAX_RATE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_MAX_RATEContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_MAX_RATE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_MAX_RATE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_MAX_RATEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_MAX_RATEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_MAX_RATEContractFunction0._type_signature: ErrorsINVALID_MAX_RATEContractFunction0,
        }
        return out


class ErrorsINVALID_MINT_AMOUNTContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_MINT_AMOUNT() method."""

    _function_name = "INVALID_MINT_AMOUNT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_MINT_AMOUNTContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_MINT_AMOUNT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_MINT_AMOUNT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_MINT_AMOUNTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_MINT_AMOUNTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_MINT_AMOUNTContractFunction0._type_signature: ErrorsINVALID_MINT_AMOUNTContractFunction0,
        }
        return out


class ErrorsINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIOContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO() method."""

    _function_name = "INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIOContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIOContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIOContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIOContractFunction0._type_signature: ErrorsINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIOContractFunction0,
        }
        return out


class ErrorsINVALID_OPTIMAL_USAGE_RATIOContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_OPTIMAL_USAGE_RATIO() method."""

    _function_name = "INVALID_OPTIMAL_USAGE_RATIO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_OPTIMAL_USAGE_RATIOContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_OPTIMAL_USAGE_RATIO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_OPTIMAL_USAGE_RATIO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_OPTIMAL_USAGE_RATIOContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_OPTIMAL_USAGE_RATIOContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_OPTIMAL_USAGE_RATIOContractFunction0._type_signature: ErrorsINVALID_OPTIMAL_USAGE_RATIOContractFunction0,
        }
        return out


class ErrorsINVALID_RESERVE_FACTORContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_RESERVE_FACTOR() method."""

    _function_name = "INVALID_RESERVE_FACTOR"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_RESERVE_FACTORContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_RESERVE_FACTOR method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_RESERVE_FACTOR"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_RESERVE_FACTORContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_RESERVE_FACTORContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_RESERVE_FACTORContractFunction0._type_signature: ErrorsINVALID_RESERVE_FACTORContractFunction0,
        }
        return out


class ErrorsINVALID_RESERVE_INDEXContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_RESERVE_INDEX() method."""

    _function_name = "INVALID_RESERVE_INDEX"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_RESERVE_INDEXContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_RESERVE_INDEX method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_RESERVE_INDEX"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_RESERVE_INDEXContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_RESERVE_INDEXContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_RESERVE_INDEXContractFunction0._type_signature: ErrorsINVALID_RESERVE_INDEXContractFunction0,
        }
        return out


class ErrorsINVALID_RESERVE_PARAMSContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_RESERVE_PARAMS() method."""

    _function_name = "INVALID_RESERVE_PARAMS"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_RESERVE_PARAMSContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_RESERVE_PARAMS method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_RESERVE_PARAMS"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_RESERVE_PARAMSContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_RESERVE_PARAMSContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_RESERVE_PARAMSContractFunction0._type_signature: ErrorsINVALID_RESERVE_PARAMSContractFunction0,
        }
        return out


class ErrorsINVALID_SIGNATUREContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_SIGNATURE() method."""

    _function_name = "INVALID_SIGNATURE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_SIGNATUREContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_SIGNATURE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_SIGNATURE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_SIGNATUREContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_SIGNATUREContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_SIGNATUREContractFunction0._type_signature: ErrorsINVALID_SIGNATUREContractFunction0,
        }
        return out


class ErrorsINVALID_SUPPLY_CAPContractFunction0(PypechainContractFunction):
    """ContractFunction for the INVALID_SUPPLY_CAP() method."""

    _function_name = "INVALID_SUPPLY_CAP"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_SUPPLY_CAPContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the INVALID_SUPPLY_CAP method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_SUPPLY_CAP"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_SUPPLY_CAPContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_SUPPLY_CAPContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_SUPPLY_CAPContractFunction0._type_signature: ErrorsINVALID_SUPPLY_CAPContractFunction0,
        }
        return out


class ErrorsINVALID_UNBACKED_MINT_CAPContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the INVALID_UNBACKED_MINT_CAP() method."""

    _function_name = "INVALID_UNBACKED_MINT_CAP"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsINVALID_UNBACKED_MINT_CAPContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the INVALID_UNBACKED_MINT_CAP method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "INVALID_UNBACKED_MINT_CAP"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsINVALID_UNBACKED_MINT_CAPContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsINVALID_UNBACKED_MINT_CAPContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsINVALID_UNBACKED_MINT_CAPContractFunction0._type_signature: ErrorsINVALID_UNBACKED_MINT_CAPContractFunction0,
        }
        return out


class ErrorsLIQUIDATION_GRACE_SENTINEL_CHECK_FAILEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED() method."""

    _function_name = "LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsLIQUIDATION_GRACE_SENTINEL_CHECK_FAILEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsLIQUIDATION_GRACE_SENTINEL_CHECK_FAILEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsLIQUIDATION_GRACE_SENTINEL_CHECK_FAILEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsLIQUIDATION_GRACE_SENTINEL_CHECK_FAILEDContractFunction0._type_signature: ErrorsLIQUIDATION_GRACE_SENTINEL_CHECK_FAILEDContractFunction0,
        }
        return out


class ErrorsLTV_VALIDATION_FAILEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the LTV_VALIDATION_FAILED() method."""

    _function_name = "LTV_VALIDATION_FAILED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsLTV_VALIDATION_FAILEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the LTV_VALIDATION_FAILED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "LTV_VALIDATION_FAILED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsLTV_VALIDATION_FAILEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsLTV_VALIDATION_FAILEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsLTV_VALIDATION_FAILEDContractFunction0._type_signature: ErrorsLTV_VALIDATION_FAILEDContractFunction0,
        }
        return out


class ErrorsNOT_CONTRACTContractFunction0(PypechainContractFunction):
    """ContractFunction for the NOT_CONTRACT() method."""

    _function_name = "NOT_CONTRACT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsNOT_CONTRACTContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the NOT_CONTRACT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "NOT_CONTRACT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsNOT_CONTRACTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsNOT_CONTRACTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsNOT_CONTRACTContractFunction0._type_signature: ErrorsNOT_CONTRACTContractFunction0,
        }
        return out


class ErrorsNOT_ENOUGH_AVAILABLE_USER_BALANCEContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the NOT_ENOUGH_AVAILABLE_USER_BALANCE() method."""

    _function_name = "NOT_ENOUGH_AVAILABLE_USER_BALANCE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsNOT_ENOUGH_AVAILABLE_USER_BALANCEContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the NOT_ENOUGH_AVAILABLE_USER_BALANCE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "NOT_ENOUGH_AVAILABLE_USER_BALANCE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsNOT_ENOUGH_AVAILABLE_USER_BALANCEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsNOT_ENOUGH_AVAILABLE_USER_BALANCEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsNOT_ENOUGH_AVAILABLE_USER_BALANCEContractFunction0._type_signature: ErrorsNOT_ENOUGH_AVAILABLE_USER_BALANCEContractFunction0,
        }
        return out


class ErrorsNO_DEBT_OF_SELECTED_TYPEContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the NO_DEBT_OF_SELECTED_TYPE() method."""

    _function_name = "NO_DEBT_OF_SELECTED_TYPE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsNO_DEBT_OF_SELECTED_TYPEContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the NO_DEBT_OF_SELECTED_TYPE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "NO_DEBT_OF_SELECTED_TYPE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsNO_DEBT_OF_SELECTED_TYPEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsNO_DEBT_OF_SELECTED_TYPEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsNO_DEBT_OF_SELECTED_TYPEContractFunction0._type_signature: ErrorsNO_DEBT_OF_SELECTED_TYPEContractFunction0,
        }
        return out


class ErrorsNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALFContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF() method."""

    _function_name = "NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALFContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALFContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALFContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALFContractFunction0._type_signature: ErrorsNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALFContractFunction0,
        }
        return out


class ErrorsNO_MORE_RESERVES_ALLOWEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the NO_MORE_RESERVES_ALLOWED() method."""

    _function_name = "NO_MORE_RESERVES_ALLOWED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsNO_MORE_RESERVES_ALLOWEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the NO_MORE_RESERVES_ALLOWED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "NO_MORE_RESERVES_ALLOWED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsNO_MORE_RESERVES_ALLOWEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsNO_MORE_RESERVES_ALLOWEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsNO_MORE_RESERVES_ALLOWEDContractFunction0._type_signature: ErrorsNO_MORE_RESERVES_ALLOWEDContractFunction0,
        }
        return out


class ErrorsNO_OUTSTANDING_STABLE_DEBTContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the NO_OUTSTANDING_STABLE_DEBT() method."""

    _function_name = "NO_OUTSTANDING_STABLE_DEBT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsNO_OUTSTANDING_STABLE_DEBTContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the NO_OUTSTANDING_STABLE_DEBT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "NO_OUTSTANDING_STABLE_DEBT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsNO_OUTSTANDING_STABLE_DEBTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsNO_OUTSTANDING_STABLE_DEBTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsNO_OUTSTANDING_STABLE_DEBTContractFunction0._type_signature: ErrorsNO_OUTSTANDING_STABLE_DEBTContractFunction0,
        }
        return out


class ErrorsNO_OUTSTANDING_VARIABLE_DEBTContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the NO_OUTSTANDING_VARIABLE_DEBT() method."""

    _function_name = "NO_OUTSTANDING_VARIABLE_DEBT"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsNO_OUTSTANDING_VARIABLE_DEBTContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the NO_OUTSTANDING_VARIABLE_DEBT method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "NO_OUTSTANDING_VARIABLE_DEBT"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsNO_OUTSTANDING_VARIABLE_DEBTContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsNO_OUTSTANDING_VARIABLE_DEBTContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsNO_OUTSTANDING_VARIABLE_DEBTContractFunction0._type_signature: ErrorsNO_OUTSTANDING_VARIABLE_DEBTContractFunction0,
        }
        return out


class ErrorsOPERATION_NOT_SUPPORTEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the OPERATION_NOT_SUPPORTED() method."""

    _function_name = "OPERATION_NOT_SUPPORTED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsOPERATION_NOT_SUPPORTEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the OPERATION_NOT_SUPPORTED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "OPERATION_NOT_SUPPORTED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsOPERATION_NOT_SUPPORTEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsOPERATION_NOT_SUPPORTEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsOPERATION_NOT_SUPPORTEDContractFunction0._type_signature: ErrorsOPERATION_NOT_SUPPORTEDContractFunction0,
        }
        return out


class ErrorsPOOL_ADDRESSES_DO_NOT_MATCHContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the POOL_ADDRESSES_DO_NOT_MATCH() method."""

    _function_name = "POOL_ADDRESSES_DO_NOT_MATCH"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsPOOL_ADDRESSES_DO_NOT_MATCHContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the POOL_ADDRESSES_DO_NOT_MATCH method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "POOL_ADDRESSES_DO_NOT_MATCH"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsPOOL_ADDRESSES_DO_NOT_MATCHContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsPOOL_ADDRESSES_DO_NOT_MATCHContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsPOOL_ADDRESSES_DO_NOT_MATCHContractFunction0._type_signature: ErrorsPOOL_ADDRESSES_DO_NOT_MATCHContractFunction0,
        }
        return out


class ErrorsPRICE_ORACLE_SENTINEL_CHECK_FAILEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the PRICE_ORACLE_SENTINEL_CHECK_FAILED() method."""

    _function_name = "PRICE_ORACLE_SENTINEL_CHECK_FAILED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsPRICE_ORACLE_SENTINEL_CHECK_FAILEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the PRICE_ORACLE_SENTINEL_CHECK_FAILED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "PRICE_ORACLE_SENTINEL_CHECK_FAILED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsPRICE_ORACLE_SENTINEL_CHECK_FAILEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsPRICE_ORACLE_SENTINEL_CHECK_FAILEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsPRICE_ORACLE_SENTINEL_CHECK_FAILEDContractFunction0._type_signature: ErrorsPRICE_ORACLE_SENTINEL_CHECK_FAILEDContractFunction0,
        }
        return out


class ErrorsRESERVE_ALREADY_ADDEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the RESERVE_ALREADY_ADDED() method."""

    _function_name = "RESERVE_ALREADY_ADDED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsRESERVE_ALREADY_ADDEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the RESERVE_ALREADY_ADDED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "RESERVE_ALREADY_ADDED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsRESERVE_ALREADY_ADDEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsRESERVE_ALREADY_ADDEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsRESERVE_ALREADY_ADDEDContractFunction0._type_signature: ErrorsRESERVE_ALREADY_ADDEDContractFunction0,
        }
        return out


class ErrorsRESERVE_ALREADY_INITIALIZEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the RESERVE_ALREADY_INITIALIZED() method."""

    _function_name = "RESERVE_ALREADY_INITIALIZED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsRESERVE_ALREADY_INITIALIZEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the RESERVE_ALREADY_INITIALIZED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "RESERVE_ALREADY_INITIALIZED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsRESERVE_ALREADY_INITIALIZEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsRESERVE_ALREADY_INITIALIZEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsRESERVE_ALREADY_INITIALIZEDContractFunction0._type_signature: ErrorsRESERVE_ALREADY_INITIALIZEDContractFunction0,
        }
        return out


class ErrorsRESERVE_DEBT_NOT_ZEROContractFunction0(PypechainContractFunction):
    """ContractFunction for the RESERVE_DEBT_NOT_ZERO() method."""

    _function_name = "RESERVE_DEBT_NOT_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsRESERVE_DEBT_NOT_ZEROContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the RESERVE_DEBT_NOT_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "RESERVE_DEBT_NOT_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsRESERVE_DEBT_NOT_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsRESERVE_DEBT_NOT_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsRESERVE_DEBT_NOT_ZEROContractFunction0._type_signature: ErrorsRESERVE_DEBT_NOT_ZEROContractFunction0,
        }
        return out


class ErrorsRESERVE_FROZENContractFunction0(PypechainContractFunction):
    """ContractFunction for the RESERVE_FROZEN() method."""

    _function_name = "RESERVE_FROZEN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsRESERVE_FROZENContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the RESERVE_FROZEN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "RESERVE_FROZEN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsRESERVE_FROZENContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsRESERVE_FROZENContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsRESERVE_FROZENContractFunction0._type_signature: ErrorsRESERVE_FROZENContractFunction0,
        }
        return out


class ErrorsRESERVE_INACTIVEContractFunction0(PypechainContractFunction):
    """ContractFunction for the RESERVE_INACTIVE() method."""

    _function_name = "RESERVE_INACTIVE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsRESERVE_INACTIVEContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the RESERVE_INACTIVE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "RESERVE_INACTIVE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsRESERVE_INACTIVEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsRESERVE_INACTIVEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsRESERVE_INACTIVEContractFunction0._type_signature: ErrorsRESERVE_INACTIVEContractFunction0,
        }
        return out


class ErrorsRESERVE_LIQUIDITY_NOT_ZEROContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the RESERVE_LIQUIDITY_NOT_ZERO() method."""

    _function_name = "RESERVE_LIQUIDITY_NOT_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsRESERVE_LIQUIDITY_NOT_ZEROContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the RESERVE_LIQUIDITY_NOT_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "RESERVE_LIQUIDITY_NOT_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsRESERVE_LIQUIDITY_NOT_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsRESERVE_LIQUIDITY_NOT_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsRESERVE_LIQUIDITY_NOT_ZEROContractFunction0._type_signature: ErrorsRESERVE_LIQUIDITY_NOT_ZEROContractFunction0,
        }
        return out


class ErrorsRESERVE_PAUSEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the RESERVE_PAUSED() method."""

    _function_name = "RESERVE_PAUSED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsRESERVE_PAUSEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the RESERVE_PAUSED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "RESERVE_PAUSED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsRESERVE_PAUSEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsRESERVE_PAUSEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsRESERVE_PAUSEDContractFunction0._type_signature: ErrorsRESERVE_PAUSEDContractFunction0,
        }
        return out


class ErrorsSILOED_BORROWING_VIOLATIONContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the SILOED_BORROWING_VIOLATION() method."""

    _function_name = "SILOED_BORROWING_VIOLATION"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsSILOED_BORROWING_VIOLATIONContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the SILOED_BORROWING_VIOLATION method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "SILOED_BORROWING_VIOLATION"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsSILOED_BORROWING_VIOLATIONContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsSILOED_BORROWING_VIOLATIONContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsSILOED_BORROWING_VIOLATIONContractFunction0._type_signature: ErrorsSILOED_BORROWING_VIOLATIONContractFunction0,
        }
        return out


class ErrorsSLOPE_2_MUST_BE_GTE_SLOPE_1ContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the SLOPE_2_MUST_BE_GTE_SLOPE_1() method."""

    _function_name = "SLOPE_2_MUST_BE_GTE_SLOPE_1"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsSLOPE_2_MUST_BE_GTE_SLOPE_1ContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the SLOPE_2_MUST_BE_GTE_SLOPE_1 method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "SLOPE_2_MUST_BE_GTE_SLOPE_1"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsSLOPE_2_MUST_BE_GTE_SLOPE_1ContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsSLOPE_2_MUST_BE_GTE_SLOPE_1ContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsSLOPE_2_MUST_BE_GTE_SLOPE_1ContractFunction0._type_signature: ErrorsSLOPE_2_MUST_BE_GTE_SLOPE_1ContractFunction0,
        }
        return out


class ErrorsSPECIFIED_CURRENCY_NOT_BORROWED_BY_USERContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER() method."""

    _function_name = "SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsSPECIFIED_CURRENCY_NOT_BORROWED_BY_USERContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsSPECIFIED_CURRENCY_NOT_BORROWED_BY_USERContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsSPECIFIED_CURRENCY_NOT_BORROWED_BY_USERContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsSPECIFIED_CURRENCY_NOT_BORROWED_BY_USERContractFunction0._type_signature: ErrorsSPECIFIED_CURRENCY_NOT_BORROWED_BY_USERContractFunction0,
        }
        return out


class ErrorsSTABLE_BORROWING_ENABLEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the STABLE_BORROWING_ENABLED() method."""

    _function_name = "STABLE_BORROWING_ENABLED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsSTABLE_BORROWING_ENABLEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the STABLE_BORROWING_ENABLED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "STABLE_BORROWING_ENABLED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsSTABLE_BORROWING_ENABLEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsSTABLE_BORROWING_ENABLEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsSTABLE_BORROWING_ENABLEDContractFunction0._type_signature: ErrorsSTABLE_BORROWING_ENABLEDContractFunction0,
        }
        return out


class ErrorsSTABLE_BORROWING_NOT_ENABLEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the STABLE_BORROWING_NOT_ENABLED() method."""

    _function_name = "STABLE_BORROWING_NOT_ENABLED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsSTABLE_BORROWING_NOT_ENABLEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the STABLE_BORROWING_NOT_ENABLED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "STABLE_BORROWING_NOT_ENABLED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsSTABLE_BORROWING_NOT_ENABLEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsSTABLE_BORROWING_NOT_ENABLEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsSTABLE_BORROWING_NOT_ENABLEDContractFunction0._type_signature: ErrorsSTABLE_BORROWING_NOT_ENABLEDContractFunction0,
        }
        return out


class ErrorsSTABLE_DEBT_NOT_ZEROContractFunction0(PypechainContractFunction):
    """ContractFunction for the STABLE_DEBT_NOT_ZERO() method."""

    _function_name = "STABLE_DEBT_NOT_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsSTABLE_DEBT_NOT_ZEROContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the STABLE_DEBT_NOT_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "STABLE_DEBT_NOT_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsSTABLE_DEBT_NOT_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsSTABLE_DEBT_NOT_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsSTABLE_DEBT_NOT_ZEROContractFunction0._type_signature: ErrorsSTABLE_DEBT_NOT_ZEROContractFunction0,
        }
        return out


class ErrorsSUPPLY_CAP_EXCEEDEDContractFunction0(PypechainContractFunction):
    """ContractFunction for the SUPPLY_CAP_EXCEEDED() method."""

    _function_name = "SUPPLY_CAP_EXCEEDED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsSUPPLY_CAP_EXCEEDEDContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the SUPPLY_CAP_EXCEEDED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "SUPPLY_CAP_EXCEEDED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsSUPPLY_CAP_EXCEEDEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsSUPPLY_CAP_EXCEEDEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsSUPPLY_CAP_EXCEEDEDContractFunction0._type_signature: ErrorsSUPPLY_CAP_EXCEEDEDContractFunction0,
        }
        return out


class ErrorsSUPPLY_TO_ATOKENContractFunction0(PypechainContractFunction):
    """ContractFunction for the SUPPLY_TO_ATOKEN() method."""

    _function_name = "SUPPLY_TO_ATOKEN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsSUPPLY_TO_ATOKENContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the SUPPLY_TO_ATOKEN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "SUPPLY_TO_ATOKEN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsSUPPLY_TO_ATOKENContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsSUPPLY_TO_ATOKENContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsSUPPLY_TO_ATOKENContractFunction0._type_signature: ErrorsSUPPLY_TO_ATOKENContractFunction0,
        }
        return out


class ErrorsUNBACKED_MINT_CAP_EXCEEDEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the UNBACKED_MINT_CAP_EXCEEDED() method."""

    _function_name = "UNBACKED_MINT_CAP_EXCEEDED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsUNBACKED_MINT_CAP_EXCEEDEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the UNBACKED_MINT_CAP_EXCEEDED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "UNBACKED_MINT_CAP_EXCEEDED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsUNBACKED_MINT_CAP_EXCEEDEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsUNBACKED_MINT_CAP_EXCEEDEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsUNBACKED_MINT_CAP_EXCEEDEDContractFunction0._type_signature: ErrorsUNBACKED_MINT_CAP_EXCEEDEDContractFunction0,
        }
        return out


class ErrorsUNDERLYING_BALANCE_ZEROContractFunction0(PypechainContractFunction):
    """ContractFunction for the UNDERLYING_BALANCE_ZERO() method."""

    _function_name = "UNDERLYING_BALANCE_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsUNDERLYING_BALANCE_ZEROContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the UNDERLYING_BALANCE_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "UNDERLYING_BALANCE_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsUNDERLYING_BALANCE_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsUNDERLYING_BALANCE_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsUNDERLYING_BALANCE_ZEROContractFunction0._type_signature: ErrorsUNDERLYING_BALANCE_ZEROContractFunction0,
        }
        return out


class ErrorsUNDERLYING_CANNOT_BE_RESCUEDContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the UNDERLYING_CANNOT_BE_RESCUED() method."""

    _function_name = "UNDERLYING_CANNOT_BE_RESCUED"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsUNDERLYING_CANNOT_BE_RESCUEDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the UNDERLYING_CANNOT_BE_RESCUED method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "UNDERLYING_CANNOT_BE_RESCUED"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsUNDERLYING_CANNOT_BE_RESCUEDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsUNDERLYING_CANNOT_BE_RESCUEDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsUNDERLYING_CANNOT_BE_RESCUEDContractFunction0._type_signature: ErrorsUNDERLYING_CANNOT_BE_RESCUEDContractFunction0,
        }
        return out


class ErrorsUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZEROContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO() method."""

    _function_name = "UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZEROContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZEROContractFunction0._type_signature: ErrorsUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZEROContractFunction0,
        }
        return out


class ErrorsUSER_IN_ISOLATION_MODE_OR_LTV_ZEROContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the USER_IN_ISOLATION_MODE_OR_LTV_ZERO() method."""

    _function_name = "USER_IN_ISOLATION_MODE_OR_LTV_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsUSER_IN_ISOLATION_MODE_OR_LTV_ZEROContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the USER_IN_ISOLATION_MODE_OR_LTV_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "USER_IN_ISOLATION_MODE_OR_LTV_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsUSER_IN_ISOLATION_MODE_OR_LTV_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsUSER_IN_ISOLATION_MODE_OR_LTV_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsUSER_IN_ISOLATION_MODE_OR_LTV_ZEROContractFunction0._type_signature: ErrorsUSER_IN_ISOLATION_MODE_OR_LTV_ZEROContractFunction0,
        }
        return out


class ErrorsVARIABLE_DEBT_SUPPLY_NOT_ZEROContractFunction0(
    PypechainContractFunction
):
    """ContractFunction for the VARIABLE_DEBT_SUPPLY_NOT_ZERO() method."""

    _function_name = "VARIABLE_DEBT_SUPPLY_NOT_ZERO"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsVARIABLE_DEBT_SUPPLY_NOT_ZEROContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the VARIABLE_DEBT_SUPPLY_NOT_ZERO method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "VARIABLE_DEBT_SUPPLY_NOT_ZERO"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsVARIABLE_DEBT_SUPPLY_NOT_ZEROContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsVARIABLE_DEBT_SUPPLY_NOT_ZEROContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsVARIABLE_DEBT_SUPPLY_NOT_ZEROContractFunction0._type_signature: ErrorsVARIABLE_DEBT_SUPPLY_NOT_ZEROContractFunction0,
        }
        return out


class ErrorsWITHDRAW_TO_ATOKENContractFunction0(PypechainContractFunction):
    """ContractFunction for the WITHDRAW_TO_ATOKEN() method."""

    _function_name = "WITHDRAW_TO_ATOKEN"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsWITHDRAW_TO_ATOKENContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the WITHDRAW_TO_ATOKEN method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "WITHDRAW_TO_ATOKEN"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsWITHDRAW_TO_ATOKENContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsWITHDRAW_TO_ATOKENContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsWITHDRAW_TO_ATOKENContractFunction0._type_signature: ErrorsWITHDRAW_TO_ATOKENContractFunction0,
        }
        return out


class ErrorsZERO_ADDRESS_NOT_VALIDContractFunction0(PypechainContractFunction):
    """ContractFunction for the ZERO_ADDRESS_NOT_VALID() method."""

    _function_name = "ZERO_ADDRESS_NOT_VALID"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = ErrorsContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )

        return cast(
            str, rename_returned_types(structs, return_types, raw_values)
        )


class ErrorsZERO_ADDRESS_NOT_VALIDContractFunction(
    PypechainOverloadedFunctions
):
    """ContractFunction for the ZERO_ADDRESS_NOT_VALID method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "ZERO_ADDRESS_NOT_VALID"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> ErrorsZERO_ADDRESS_NOT_VALIDContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> ErrorsZERO_ADDRESS_NOT_VALIDContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(
            self._function_name, **factory_kwargs
        )

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            ErrorsZERO_ADDRESS_NOT_VALIDContractFunction0._type_signature: ErrorsZERO_ADDRESS_NOT_VALIDContractFunction0,
        }
        return out


class ErrorsContractFunctions(ContractFunctions):
    """ContractFunctions for the Errors contract."""

    ACL_ADMIN_CANNOT_BE_ZERO: ErrorsACL_ADMIN_CANNOT_BE_ZEROContractFunction

    ADDRESSES_PROVIDER_ALREADY_ADDED: (
        ErrorsADDRESSES_PROVIDER_ALREADY_ADDEDContractFunction
    )

    ADDRESSES_PROVIDER_NOT_REGISTERED: (
        ErrorsADDRESSES_PROVIDER_NOT_REGISTEREDContractFunction
    )

    AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE: (
        ErrorsAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLEContractFunction
    )

    ASSET_NOT_BORROWABLE_IN_ISOLATION: (
        ErrorsASSET_NOT_BORROWABLE_IN_ISOLATIONContractFunction
    )

    ASSET_NOT_LISTED: ErrorsASSET_NOT_LISTEDContractFunction

    BORROWING_NOT_ENABLED: ErrorsBORROWING_NOT_ENABLEDContractFunction

    BORROW_CAP_EXCEEDED: ErrorsBORROW_CAP_EXCEEDEDContractFunction

    BRIDGE_PROTOCOL_FEE_INVALID: (
        ErrorsBRIDGE_PROTOCOL_FEE_INVALIDContractFunction
    )

    CALLER_MUST_BE_POOL: ErrorsCALLER_MUST_BE_POOLContractFunction

    CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN: (
        ErrorsCALLER_NOT_ASSET_LISTING_OR_POOL_ADMINContractFunction
    )

    CALLER_NOT_ATOKEN: ErrorsCALLER_NOT_ATOKENContractFunction

    CALLER_NOT_BRIDGE: ErrorsCALLER_NOT_BRIDGEContractFunction

    CALLER_NOT_EMERGENCY_ADMIN: ErrorsCALLER_NOT_EMERGENCY_ADMINContractFunction

    CALLER_NOT_POOL_ADMIN: ErrorsCALLER_NOT_POOL_ADMINContractFunction

    CALLER_NOT_POOL_CONFIGURATOR: (
        ErrorsCALLER_NOT_POOL_CONFIGURATORContractFunction
    )

    CALLER_NOT_POOL_OR_EMERGENCY_ADMIN: (
        ErrorsCALLER_NOT_POOL_OR_EMERGENCY_ADMINContractFunction
    )

    CALLER_NOT_RISK_OR_POOL_ADMIN: (
        ErrorsCALLER_NOT_RISK_OR_POOL_ADMINContractFunction
    )

    CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN: (
        ErrorsCALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMINContractFunction
    )

    COLLATERAL_BALANCE_IS_ZERO: ErrorsCOLLATERAL_BALANCE_IS_ZEROContractFunction

    COLLATERAL_CANNOT_BE_LIQUIDATED: (
        ErrorsCOLLATERAL_CANNOT_BE_LIQUIDATEDContractFunction
    )

    COLLATERAL_CANNOT_COVER_NEW_BORROW: (
        ErrorsCOLLATERAL_CANNOT_COVER_NEW_BORROWContractFunction
    )

    COLLATERAL_SAME_AS_BORROWING_CURRENCY: (
        ErrorsCOLLATERAL_SAME_AS_BORROWING_CURRENCYContractFunction
    )

    DEBT_CEILING_EXCEEDED: ErrorsDEBT_CEILING_EXCEEDEDContractFunction

    DEBT_CEILING_NOT_ZERO: ErrorsDEBT_CEILING_NOT_ZEROContractFunction

    EMODE_CATEGORY_RESERVED: ErrorsEMODE_CATEGORY_RESERVEDContractFunction

    FLASHLOAN_DISABLED: ErrorsFLASHLOAN_DISABLEDContractFunction

    FLASHLOAN_PREMIUM_INVALID: ErrorsFLASHLOAN_PREMIUM_INVALIDContractFunction

    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD: (
        ErrorsHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLDContractFunction
    )

    HEALTH_FACTOR_NOT_BELOW_THRESHOLD: (
        ErrorsHEALTH_FACTOR_NOT_BELOW_THRESHOLDContractFunction
    )

    INCONSISTENT_EMODE_CATEGORY: (
        ErrorsINCONSISTENT_EMODE_CATEGORYContractFunction
    )

    INCONSISTENT_FLASHLOAN_PARAMS: (
        ErrorsINCONSISTENT_FLASHLOAN_PARAMSContractFunction
    )

    INCONSISTENT_PARAMS_LENGTH: ErrorsINCONSISTENT_PARAMS_LENGTHContractFunction

    INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET: (
        ErrorsINTEREST_RATE_REBALANCE_CONDITIONS_NOT_METContractFunction
    )

    INVALID_ADDRESSES_PROVIDER: ErrorsINVALID_ADDRESSES_PROVIDERContractFunction

    INVALID_ADDRESSES_PROVIDER_ID: (
        ErrorsINVALID_ADDRESSES_PROVIDER_IDContractFunction
    )

    INVALID_AMOUNT: ErrorsINVALID_AMOUNTContractFunction

    INVALID_BORROW_CAP: ErrorsINVALID_BORROW_CAPContractFunction

    INVALID_BURN_AMOUNT: ErrorsINVALID_BURN_AMOUNTContractFunction

    INVALID_DEBT_CEILING: ErrorsINVALID_DEBT_CEILINGContractFunction

    INVALID_DECIMALS: ErrorsINVALID_DECIMALSContractFunction

    INVALID_EMODE_CATEGORY: ErrorsINVALID_EMODE_CATEGORYContractFunction

    INVALID_EMODE_CATEGORY_ASSIGNMENT: (
        ErrorsINVALID_EMODE_CATEGORY_ASSIGNMENTContractFunction
    )

    INVALID_EMODE_CATEGORY_PARAMS: (
        ErrorsINVALID_EMODE_CATEGORY_PARAMSContractFunction
    )

    INVALID_EXPIRATION: ErrorsINVALID_EXPIRATIONContractFunction

    INVALID_FLASHLOAN_EXECUTOR_RETURN: (
        ErrorsINVALID_FLASHLOAN_EXECUTOR_RETURNContractFunction
    )

    INVALID_FREEZE_STATE: ErrorsINVALID_FREEZE_STATEContractFunction

    INVALID_GRACE_PERIOD: ErrorsINVALID_GRACE_PERIODContractFunction

    INVALID_INTEREST_RATE_MODE_SELECTED: (
        ErrorsINVALID_INTEREST_RATE_MODE_SELECTEDContractFunction
    )

    INVALID_LIQUIDATION_PROTOCOL_FEE: (
        ErrorsINVALID_LIQUIDATION_PROTOCOL_FEEContractFunction
    )

    INVALID_LIQ_BONUS: ErrorsINVALID_LIQ_BONUSContractFunction

    INVALID_LIQ_THRESHOLD: ErrorsINVALID_LIQ_THRESHOLDContractFunction

    INVALID_LTV: ErrorsINVALID_LTVContractFunction

    INVALID_MAX_RATE: ErrorsINVALID_MAX_RATEContractFunction

    INVALID_MINT_AMOUNT: ErrorsINVALID_MINT_AMOUNTContractFunction

    INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO: (
        ErrorsINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIOContractFunction
    )

    INVALID_OPTIMAL_USAGE_RATIO: (
        ErrorsINVALID_OPTIMAL_USAGE_RATIOContractFunction
    )

    INVALID_RESERVE_FACTOR: ErrorsINVALID_RESERVE_FACTORContractFunction

    INVALID_RESERVE_INDEX: ErrorsINVALID_RESERVE_INDEXContractFunction

    INVALID_RESERVE_PARAMS: ErrorsINVALID_RESERVE_PARAMSContractFunction

    INVALID_SIGNATURE: ErrorsINVALID_SIGNATUREContractFunction

    INVALID_SUPPLY_CAP: ErrorsINVALID_SUPPLY_CAPContractFunction

    INVALID_UNBACKED_MINT_CAP: ErrorsINVALID_UNBACKED_MINT_CAPContractFunction

    LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED: (
        ErrorsLIQUIDATION_GRACE_SENTINEL_CHECK_FAILEDContractFunction
    )

    LTV_VALIDATION_FAILED: ErrorsLTV_VALIDATION_FAILEDContractFunction

    NOT_CONTRACT: ErrorsNOT_CONTRACTContractFunction

    NOT_ENOUGH_AVAILABLE_USER_BALANCE: (
        ErrorsNOT_ENOUGH_AVAILABLE_USER_BALANCEContractFunction
    )

    NO_DEBT_OF_SELECTED_TYPE: ErrorsNO_DEBT_OF_SELECTED_TYPEContractFunction

    NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF: (
        ErrorsNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALFContractFunction
    )

    NO_MORE_RESERVES_ALLOWED: ErrorsNO_MORE_RESERVES_ALLOWEDContractFunction

    NO_OUTSTANDING_STABLE_DEBT: ErrorsNO_OUTSTANDING_STABLE_DEBTContractFunction

    NO_OUTSTANDING_VARIABLE_DEBT: (
        ErrorsNO_OUTSTANDING_VARIABLE_DEBTContractFunction
    )

    OPERATION_NOT_SUPPORTED: ErrorsOPERATION_NOT_SUPPORTEDContractFunction

    POOL_ADDRESSES_DO_NOT_MATCH: (
        ErrorsPOOL_ADDRESSES_DO_NOT_MATCHContractFunction
    )

    PRICE_ORACLE_SENTINEL_CHECK_FAILED: (
        ErrorsPRICE_ORACLE_SENTINEL_CHECK_FAILEDContractFunction
    )

    RESERVE_ALREADY_ADDED: ErrorsRESERVE_ALREADY_ADDEDContractFunction

    RESERVE_ALREADY_INITIALIZED: (
        ErrorsRESERVE_ALREADY_INITIALIZEDContractFunction
    )

    RESERVE_DEBT_NOT_ZERO: ErrorsRESERVE_DEBT_NOT_ZEROContractFunction

    RESERVE_FROZEN: ErrorsRESERVE_FROZENContractFunction

    RESERVE_INACTIVE: ErrorsRESERVE_INACTIVEContractFunction

    RESERVE_LIQUIDITY_NOT_ZERO: ErrorsRESERVE_LIQUIDITY_NOT_ZEROContractFunction

    RESERVE_PAUSED: ErrorsRESERVE_PAUSEDContractFunction

    SILOED_BORROWING_VIOLATION: ErrorsSILOED_BORROWING_VIOLATIONContractFunction

    SLOPE_2_MUST_BE_GTE_SLOPE_1: (
        ErrorsSLOPE_2_MUST_BE_GTE_SLOPE_1ContractFunction
    )

    SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER: (
        ErrorsSPECIFIED_CURRENCY_NOT_BORROWED_BY_USERContractFunction
    )

    STABLE_BORROWING_ENABLED: ErrorsSTABLE_BORROWING_ENABLEDContractFunction

    STABLE_BORROWING_NOT_ENABLED: (
        ErrorsSTABLE_BORROWING_NOT_ENABLEDContractFunction
    )

    STABLE_DEBT_NOT_ZERO: ErrorsSTABLE_DEBT_NOT_ZEROContractFunction

    SUPPLY_CAP_EXCEEDED: ErrorsSUPPLY_CAP_EXCEEDEDContractFunction

    SUPPLY_TO_ATOKEN: ErrorsSUPPLY_TO_ATOKENContractFunction

    UNBACKED_MINT_CAP_EXCEEDED: ErrorsUNBACKED_MINT_CAP_EXCEEDEDContractFunction

    UNDERLYING_BALANCE_ZERO: ErrorsUNDERLYING_BALANCE_ZEROContractFunction

    UNDERLYING_CANNOT_BE_RESCUED: (
        ErrorsUNDERLYING_CANNOT_BE_RESCUEDContractFunction
    )

    UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO: (
        ErrorsUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZEROContractFunction
    )

    USER_IN_ISOLATION_MODE_OR_LTV_ZERO: (
        ErrorsUSER_IN_ISOLATION_MODE_OR_LTV_ZEROContractFunction
    )

    VARIABLE_DEBT_SUPPLY_NOT_ZERO: (
        ErrorsVARIABLE_DEBT_SUPPLY_NOT_ZEROContractFunction
    )

    WITHDRAW_TO_ATOKEN: ErrorsWITHDRAW_TO_ATOKENContractFunction

    ZERO_ADDRESS_NOT_VALID: ErrorsZERO_ADDRESS_NOT_VALIDContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.ACL_ADMIN_CANNOT_BE_ZERO = (
            ErrorsACL_ADMIN_CANNOT_BE_ZEROContractFunction.factory(
                "ACL_ADMIN_CANNOT_BE_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ACL_ADMIN_CANNOT_BE_ZERO",
            )
        )
        self.ADDRESSES_PROVIDER_ALREADY_ADDED = (
            ErrorsADDRESSES_PROVIDER_ALREADY_ADDEDContractFunction.factory(
                "ADDRESSES_PROVIDER_ALREADY_ADDED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ADDRESSES_PROVIDER_ALREADY_ADDED",
            )
        )
        self.ADDRESSES_PROVIDER_NOT_REGISTERED = (
            ErrorsADDRESSES_PROVIDER_NOT_REGISTEREDContractFunction.factory(
                "ADDRESSES_PROVIDER_NOT_REGISTERED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ADDRESSES_PROVIDER_NOT_REGISTERED",
            )
        )
        self.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = ErrorsAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLEContractFunction.factory(
            "AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE",
        )
        self.ASSET_NOT_BORROWABLE_IN_ISOLATION = (
            ErrorsASSET_NOT_BORROWABLE_IN_ISOLATIONContractFunction.factory(
                "ASSET_NOT_BORROWABLE_IN_ISOLATION",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ASSET_NOT_BORROWABLE_IN_ISOLATION",
            )
        )
        self.ASSET_NOT_LISTED = ErrorsASSET_NOT_LISTEDContractFunction.factory(
            "ASSET_NOT_LISTED",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="ASSET_NOT_LISTED",
        )
        self.BORROWING_NOT_ENABLED = (
            ErrorsBORROWING_NOT_ENABLEDContractFunction.factory(
                "BORROWING_NOT_ENABLED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="BORROWING_NOT_ENABLED",
            )
        )
        self.BORROW_CAP_EXCEEDED = (
            ErrorsBORROW_CAP_EXCEEDEDContractFunction.factory(
                "BORROW_CAP_EXCEEDED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="BORROW_CAP_EXCEEDED",
            )
        )
        self.BRIDGE_PROTOCOL_FEE_INVALID = (
            ErrorsBRIDGE_PROTOCOL_FEE_INVALIDContractFunction.factory(
                "BRIDGE_PROTOCOL_FEE_INVALID",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="BRIDGE_PROTOCOL_FEE_INVALID",
            )
        )
        self.CALLER_MUST_BE_POOL = (
            ErrorsCALLER_MUST_BE_POOLContractFunction.factory(
                "CALLER_MUST_BE_POOL",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="CALLER_MUST_BE_POOL",
            )
        )
        self.CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = ErrorsCALLER_NOT_ASSET_LISTING_OR_POOL_ADMINContractFunction.factory(
            "CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN",
        )
        self.CALLER_NOT_ATOKEN = (
            ErrorsCALLER_NOT_ATOKENContractFunction.factory(
                "CALLER_NOT_ATOKEN",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="CALLER_NOT_ATOKEN",
            )
        )
        self.CALLER_NOT_BRIDGE = (
            ErrorsCALLER_NOT_BRIDGEContractFunction.factory(
                "CALLER_NOT_BRIDGE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="CALLER_NOT_BRIDGE",
            )
        )
        self.CALLER_NOT_EMERGENCY_ADMIN = (
            ErrorsCALLER_NOT_EMERGENCY_ADMINContractFunction.factory(
                "CALLER_NOT_EMERGENCY_ADMIN",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="CALLER_NOT_EMERGENCY_ADMIN",
            )
        )
        self.CALLER_NOT_POOL_ADMIN = (
            ErrorsCALLER_NOT_POOL_ADMINContractFunction.factory(
                "CALLER_NOT_POOL_ADMIN",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="CALLER_NOT_POOL_ADMIN",
            )
        )
        self.CALLER_NOT_POOL_CONFIGURATOR = (
            ErrorsCALLER_NOT_POOL_CONFIGURATORContractFunction.factory(
                "CALLER_NOT_POOL_CONFIGURATOR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="CALLER_NOT_POOL_CONFIGURATOR",
            )
        )
        self.CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = (
            ErrorsCALLER_NOT_POOL_OR_EMERGENCY_ADMINContractFunction.factory(
                "CALLER_NOT_POOL_OR_EMERGENCY_ADMIN",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="CALLER_NOT_POOL_OR_EMERGENCY_ADMIN",
            )
        )
        self.CALLER_NOT_RISK_OR_POOL_ADMIN = (
            ErrorsCALLER_NOT_RISK_OR_POOL_ADMINContractFunction.factory(
                "CALLER_NOT_RISK_OR_POOL_ADMIN",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="CALLER_NOT_RISK_OR_POOL_ADMIN",
            )
        )
        self.CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN = ErrorsCALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMINContractFunction.factory(
            "CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN",
        )
        self.COLLATERAL_BALANCE_IS_ZERO = (
            ErrorsCOLLATERAL_BALANCE_IS_ZEROContractFunction.factory(
                "COLLATERAL_BALANCE_IS_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="COLLATERAL_BALANCE_IS_ZERO",
            )
        )
        self.COLLATERAL_CANNOT_BE_LIQUIDATED = (
            ErrorsCOLLATERAL_CANNOT_BE_LIQUIDATEDContractFunction.factory(
                "COLLATERAL_CANNOT_BE_LIQUIDATED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="COLLATERAL_CANNOT_BE_LIQUIDATED",
            )
        )
        self.COLLATERAL_CANNOT_COVER_NEW_BORROW = (
            ErrorsCOLLATERAL_CANNOT_COVER_NEW_BORROWContractFunction.factory(
                "COLLATERAL_CANNOT_COVER_NEW_BORROW",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="COLLATERAL_CANNOT_COVER_NEW_BORROW",
            )
        )
        self.COLLATERAL_SAME_AS_BORROWING_CURRENCY = (
            ErrorsCOLLATERAL_SAME_AS_BORROWING_CURRENCYContractFunction.factory(
                "COLLATERAL_SAME_AS_BORROWING_CURRENCY",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="COLLATERAL_SAME_AS_BORROWING_CURRENCY",
            )
        )
        self.DEBT_CEILING_EXCEEDED = (
            ErrorsDEBT_CEILING_EXCEEDEDContractFunction.factory(
                "DEBT_CEILING_EXCEEDED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="DEBT_CEILING_EXCEEDED",
            )
        )
        self.DEBT_CEILING_NOT_ZERO = (
            ErrorsDEBT_CEILING_NOT_ZEROContractFunction.factory(
                "DEBT_CEILING_NOT_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="DEBT_CEILING_NOT_ZERO",
            )
        )
        self.EMODE_CATEGORY_RESERVED = (
            ErrorsEMODE_CATEGORY_RESERVEDContractFunction.factory(
                "EMODE_CATEGORY_RESERVED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="EMODE_CATEGORY_RESERVED",
            )
        )
        self.FLASHLOAN_DISABLED = (
            ErrorsFLASHLOAN_DISABLEDContractFunction.factory(
                "FLASHLOAN_DISABLED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_DISABLED",
            )
        )
        self.FLASHLOAN_PREMIUM_INVALID = (
            ErrorsFLASHLOAN_PREMIUM_INVALIDContractFunction.factory(
                "FLASHLOAN_PREMIUM_INVALID",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="FLASHLOAN_PREMIUM_INVALID",
            )
        )
        self.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = ErrorsHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLDContractFunction.factory(
            "HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD",
        )
        self.HEALTH_FACTOR_NOT_BELOW_THRESHOLD = (
            ErrorsHEALTH_FACTOR_NOT_BELOW_THRESHOLDContractFunction.factory(
                "HEALTH_FACTOR_NOT_BELOW_THRESHOLD",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="HEALTH_FACTOR_NOT_BELOW_THRESHOLD",
            )
        )
        self.INCONSISTENT_EMODE_CATEGORY = (
            ErrorsINCONSISTENT_EMODE_CATEGORYContractFunction.factory(
                "INCONSISTENT_EMODE_CATEGORY",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INCONSISTENT_EMODE_CATEGORY",
            )
        )
        self.INCONSISTENT_FLASHLOAN_PARAMS = (
            ErrorsINCONSISTENT_FLASHLOAN_PARAMSContractFunction.factory(
                "INCONSISTENT_FLASHLOAN_PARAMS",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INCONSISTENT_FLASHLOAN_PARAMS",
            )
        )
        self.INCONSISTENT_PARAMS_LENGTH = (
            ErrorsINCONSISTENT_PARAMS_LENGTHContractFunction.factory(
                "INCONSISTENT_PARAMS_LENGTH",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INCONSISTENT_PARAMS_LENGTH",
            )
        )
        self.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = ErrorsINTEREST_RATE_REBALANCE_CONDITIONS_NOT_METContractFunction.factory(
            "INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET",
        )
        self.INVALID_ADDRESSES_PROVIDER = (
            ErrorsINVALID_ADDRESSES_PROVIDERContractFunction.factory(
                "INVALID_ADDRESSES_PROVIDER",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_ADDRESSES_PROVIDER",
            )
        )
        self.INVALID_ADDRESSES_PROVIDER_ID = (
            ErrorsINVALID_ADDRESSES_PROVIDER_IDContractFunction.factory(
                "INVALID_ADDRESSES_PROVIDER_ID",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_ADDRESSES_PROVIDER_ID",
            )
        )
        self.INVALID_AMOUNT = ErrorsINVALID_AMOUNTContractFunction.factory(
            "INVALID_AMOUNT",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="INVALID_AMOUNT",
        )
        self.INVALID_BORROW_CAP = (
            ErrorsINVALID_BORROW_CAPContractFunction.factory(
                "INVALID_BORROW_CAP",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_BORROW_CAP",
            )
        )
        self.INVALID_BURN_AMOUNT = (
            ErrorsINVALID_BURN_AMOUNTContractFunction.factory(
                "INVALID_BURN_AMOUNT",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_BURN_AMOUNT",
            )
        )
        self.INVALID_DEBT_CEILING = (
            ErrorsINVALID_DEBT_CEILINGContractFunction.factory(
                "INVALID_DEBT_CEILING",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_DEBT_CEILING",
            )
        )
        self.INVALID_DECIMALS = ErrorsINVALID_DECIMALSContractFunction.factory(
            "INVALID_DECIMALS",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="INVALID_DECIMALS",
        )
        self.INVALID_EMODE_CATEGORY = (
            ErrorsINVALID_EMODE_CATEGORYContractFunction.factory(
                "INVALID_EMODE_CATEGORY",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_EMODE_CATEGORY",
            )
        )
        self.INVALID_EMODE_CATEGORY_ASSIGNMENT = (
            ErrorsINVALID_EMODE_CATEGORY_ASSIGNMENTContractFunction.factory(
                "INVALID_EMODE_CATEGORY_ASSIGNMENT",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_EMODE_CATEGORY_ASSIGNMENT",
            )
        )
        self.INVALID_EMODE_CATEGORY_PARAMS = (
            ErrorsINVALID_EMODE_CATEGORY_PARAMSContractFunction.factory(
                "INVALID_EMODE_CATEGORY_PARAMS",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_EMODE_CATEGORY_PARAMS",
            )
        )
        self.INVALID_EXPIRATION = (
            ErrorsINVALID_EXPIRATIONContractFunction.factory(
                "INVALID_EXPIRATION",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_EXPIRATION",
            )
        )
        self.INVALID_FLASHLOAN_EXECUTOR_RETURN = (
            ErrorsINVALID_FLASHLOAN_EXECUTOR_RETURNContractFunction.factory(
                "INVALID_FLASHLOAN_EXECUTOR_RETURN",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_FLASHLOAN_EXECUTOR_RETURN",
            )
        )
        self.INVALID_FREEZE_STATE = (
            ErrorsINVALID_FREEZE_STATEContractFunction.factory(
                "INVALID_FREEZE_STATE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_FREEZE_STATE",
            )
        )
        self.INVALID_GRACE_PERIOD = (
            ErrorsINVALID_GRACE_PERIODContractFunction.factory(
                "INVALID_GRACE_PERIOD",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_GRACE_PERIOD",
            )
        )
        self.INVALID_INTEREST_RATE_MODE_SELECTED = (
            ErrorsINVALID_INTEREST_RATE_MODE_SELECTEDContractFunction.factory(
                "INVALID_INTEREST_RATE_MODE_SELECTED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_INTEREST_RATE_MODE_SELECTED",
            )
        )
        self.INVALID_LIQUIDATION_PROTOCOL_FEE = (
            ErrorsINVALID_LIQUIDATION_PROTOCOL_FEEContractFunction.factory(
                "INVALID_LIQUIDATION_PROTOCOL_FEE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_LIQUIDATION_PROTOCOL_FEE",
            )
        )
        self.INVALID_LIQ_BONUS = (
            ErrorsINVALID_LIQ_BONUSContractFunction.factory(
                "INVALID_LIQ_BONUS",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_LIQ_BONUS",
            )
        )
        self.INVALID_LIQ_THRESHOLD = (
            ErrorsINVALID_LIQ_THRESHOLDContractFunction.factory(
                "INVALID_LIQ_THRESHOLD",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_LIQ_THRESHOLD",
            )
        )
        self.INVALID_LTV = ErrorsINVALID_LTVContractFunction.factory(
            "INVALID_LTV",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="INVALID_LTV",
        )
        self.INVALID_MAX_RATE = ErrorsINVALID_MAX_RATEContractFunction.factory(
            "INVALID_MAX_RATE",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="INVALID_MAX_RATE",
        )
        self.INVALID_MINT_AMOUNT = (
            ErrorsINVALID_MINT_AMOUNTContractFunction.factory(
                "INVALID_MINT_AMOUNT",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_MINT_AMOUNT",
            )
        )
        self.INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = ErrorsINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIOContractFunction.factory(
            "INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO",
        )
        self.INVALID_OPTIMAL_USAGE_RATIO = (
            ErrorsINVALID_OPTIMAL_USAGE_RATIOContractFunction.factory(
                "INVALID_OPTIMAL_USAGE_RATIO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_OPTIMAL_USAGE_RATIO",
            )
        )
        self.INVALID_RESERVE_FACTOR = (
            ErrorsINVALID_RESERVE_FACTORContractFunction.factory(
                "INVALID_RESERVE_FACTOR",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_RESERVE_FACTOR",
            )
        )
        self.INVALID_RESERVE_INDEX = (
            ErrorsINVALID_RESERVE_INDEXContractFunction.factory(
                "INVALID_RESERVE_INDEX",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_RESERVE_INDEX",
            )
        )
        self.INVALID_RESERVE_PARAMS = (
            ErrorsINVALID_RESERVE_PARAMSContractFunction.factory(
                "INVALID_RESERVE_PARAMS",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_RESERVE_PARAMS",
            )
        )
        self.INVALID_SIGNATURE = (
            ErrorsINVALID_SIGNATUREContractFunction.factory(
                "INVALID_SIGNATURE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_SIGNATURE",
            )
        )
        self.INVALID_SUPPLY_CAP = (
            ErrorsINVALID_SUPPLY_CAPContractFunction.factory(
                "INVALID_SUPPLY_CAP",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_SUPPLY_CAP",
            )
        )
        self.INVALID_UNBACKED_MINT_CAP = (
            ErrorsINVALID_UNBACKED_MINT_CAPContractFunction.factory(
                "INVALID_UNBACKED_MINT_CAP",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="INVALID_UNBACKED_MINT_CAP",
            )
        )
        self.LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED = ErrorsLIQUIDATION_GRACE_SENTINEL_CHECK_FAILEDContractFunction.factory(
            "LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED",
        )
        self.LTV_VALIDATION_FAILED = (
            ErrorsLTV_VALIDATION_FAILEDContractFunction.factory(
                "LTV_VALIDATION_FAILED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="LTV_VALIDATION_FAILED",
            )
        )
        self.NOT_CONTRACT = ErrorsNOT_CONTRACTContractFunction.factory(
            "NOT_CONTRACT",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="NOT_CONTRACT",
        )
        self.NOT_ENOUGH_AVAILABLE_USER_BALANCE = (
            ErrorsNOT_ENOUGH_AVAILABLE_USER_BALANCEContractFunction.factory(
                "NOT_ENOUGH_AVAILABLE_USER_BALANCE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="NOT_ENOUGH_AVAILABLE_USER_BALANCE",
            )
        )
        self.NO_DEBT_OF_SELECTED_TYPE = (
            ErrorsNO_DEBT_OF_SELECTED_TYPEContractFunction.factory(
                "NO_DEBT_OF_SELECTED_TYPE",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="NO_DEBT_OF_SELECTED_TYPE",
            )
        )
        self.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = (
            ErrorsNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALFContractFunction.factory(
                "NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF",
            )
        )
        self.NO_MORE_RESERVES_ALLOWED = (
            ErrorsNO_MORE_RESERVES_ALLOWEDContractFunction.factory(
                "NO_MORE_RESERVES_ALLOWED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="NO_MORE_RESERVES_ALLOWED",
            )
        )
        self.NO_OUTSTANDING_STABLE_DEBT = (
            ErrorsNO_OUTSTANDING_STABLE_DEBTContractFunction.factory(
                "NO_OUTSTANDING_STABLE_DEBT",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="NO_OUTSTANDING_STABLE_DEBT",
            )
        )
        self.NO_OUTSTANDING_VARIABLE_DEBT = (
            ErrorsNO_OUTSTANDING_VARIABLE_DEBTContractFunction.factory(
                "NO_OUTSTANDING_VARIABLE_DEBT",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="NO_OUTSTANDING_VARIABLE_DEBT",
            )
        )
        self.OPERATION_NOT_SUPPORTED = (
            ErrorsOPERATION_NOT_SUPPORTEDContractFunction.factory(
                "OPERATION_NOT_SUPPORTED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="OPERATION_NOT_SUPPORTED",
            )
        )
        self.POOL_ADDRESSES_DO_NOT_MATCH = (
            ErrorsPOOL_ADDRESSES_DO_NOT_MATCHContractFunction.factory(
                "POOL_ADDRESSES_DO_NOT_MATCH",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="POOL_ADDRESSES_DO_NOT_MATCH",
            )
        )
        self.PRICE_ORACLE_SENTINEL_CHECK_FAILED = (
            ErrorsPRICE_ORACLE_SENTINEL_CHECK_FAILEDContractFunction.factory(
                "PRICE_ORACLE_SENTINEL_CHECK_FAILED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="PRICE_ORACLE_SENTINEL_CHECK_FAILED",
            )
        )
        self.RESERVE_ALREADY_ADDED = (
            ErrorsRESERVE_ALREADY_ADDEDContractFunction.factory(
                "RESERVE_ALREADY_ADDED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="RESERVE_ALREADY_ADDED",
            )
        )
        self.RESERVE_ALREADY_INITIALIZED = (
            ErrorsRESERVE_ALREADY_INITIALIZEDContractFunction.factory(
                "RESERVE_ALREADY_INITIALIZED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="RESERVE_ALREADY_INITIALIZED",
            )
        )
        self.RESERVE_DEBT_NOT_ZERO = (
            ErrorsRESERVE_DEBT_NOT_ZEROContractFunction.factory(
                "RESERVE_DEBT_NOT_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="RESERVE_DEBT_NOT_ZERO",
            )
        )
        self.RESERVE_FROZEN = ErrorsRESERVE_FROZENContractFunction.factory(
            "RESERVE_FROZEN",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="RESERVE_FROZEN",
        )
        self.RESERVE_INACTIVE = ErrorsRESERVE_INACTIVEContractFunction.factory(
            "RESERVE_INACTIVE",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="RESERVE_INACTIVE",
        )
        self.RESERVE_LIQUIDITY_NOT_ZERO = (
            ErrorsRESERVE_LIQUIDITY_NOT_ZEROContractFunction.factory(
                "RESERVE_LIQUIDITY_NOT_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="RESERVE_LIQUIDITY_NOT_ZERO",
            )
        )
        self.RESERVE_PAUSED = ErrorsRESERVE_PAUSEDContractFunction.factory(
            "RESERVE_PAUSED",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="RESERVE_PAUSED",
        )
        self.SILOED_BORROWING_VIOLATION = (
            ErrorsSILOED_BORROWING_VIOLATIONContractFunction.factory(
                "SILOED_BORROWING_VIOLATION",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="SILOED_BORROWING_VIOLATION",
            )
        )
        self.SLOPE_2_MUST_BE_GTE_SLOPE_1 = (
            ErrorsSLOPE_2_MUST_BE_GTE_SLOPE_1ContractFunction.factory(
                "SLOPE_2_MUST_BE_GTE_SLOPE_1",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="SLOPE_2_MUST_BE_GTE_SLOPE_1",
            )
        )
        self.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = ErrorsSPECIFIED_CURRENCY_NOT_BORROWED_BY_USERContractFunction.factory(
            "SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER",
        )
        self.STABLE_BORROWING_ENABLED = (
            ErrorsSTABLE_BORROWING_ENABLEDContractFunction.factory(
                "STABLE_BORROWING_ENABLED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="STABLE_BORROWING_ENABLED",
            )
        )
        self.STABLE_BORROWING_NOT_ENABLED = (
            ErrorsSTABLE_BORROWING_NOT_ENABLEDContractFunction.factory(
                "STABLE_BORROWING_NOT_ENABLED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="STABLE_BORROWING_NOT_ENABLED",
            )
        )
        self.STABLE_DEBT_NOT_ZERO = (
            ErrorsSTABLE_DEBT_NOT_ZEROContractFunction.factory(
                "STABLE_DEBT_NOT_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="STABLE_DEBT_NOT_ZERO",
            )
        )
        self.SUPPLY_CAP_EXCEEDED = (
            ErrorsSUPPLY_CAP_EXCEEDEDContractFunction.factory(
                "SUPPLY_CAP_EXCEEDED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="SUPPLY_CAP_EXCEEDED",
            )
        )
        self.SUPPLY_TO_ATOKEN = ErrorsSUPPLY_TO_ATOKENContractFunction.factory(
            "SUPPLY_TO_ATOKEN",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="SUPPLY_TO_ATOKEN",
        )
        self.UNBACKED_MINT_CAP_EXCEEDED = (
            ErrorsUNBACKED_MINT_CAP_EXCEEDEDContractFunction.factory(
                "UNBACKED_MINT_CAP_EXCEEDED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="UNBACKED_MINT_CAP_EXCEEDED",
            )
        )
        self.UNDERLYING_BALANCE_ZERO = (
            ErrorsUNDERLYING_BALANCE_ZEROContractFunction.factory(
                "UNDERLYING_BALANCE_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="UNDERLYING_BALANCE_ZERO",
            )
        )
        self.UNDERLYING_CANNOT_BE_RESCUED = (
            ErrorsUNDERLYING_CANNOT_BE_RESCUEDContractFunction.factory(
                "UNDERLYING_CANNOT_BE_RESCUED",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="UNDERLYING_CANNOT_BE_RESCUED",
            )
        )
        self.UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = (
            ErrorsUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZEROContractFunction.factory(
                "UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO",
            )
        )
        self.USER_IN_ISOLATION_MODE_OR_LTV_ZERO = (
            ErrorsUSER_IN_ISOLATION_MODE_OR_LTV_ZEROContractFunction.factory(
                "USER_IN_ISOLATION_MODE_OR_LTV_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="USER_IN_ISOLATION_MODE_OR_LTV_ZERO",
            )
        )
        self.VARIABLE_DEBT_SUPPLY_NOT_ZERO = (
            ErrorsVARIABLE_DEBT_SUPPLY_NOT_ZEROContractFunction.factory(
                "VARIABLE_DEBT_SUPPLY_NOT_ZERO",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="VARIABLE_DEBT_SUPPLY_NOT_ZERO",
            )
        )
        self.WITHDRAW_TO_ATOKEN = (
            ErrorsWITHDRAW_TO_ATOKENContractFunction.factory(
                "WITHDRAW_TO_ATOKEN",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="WITHDRAW_TO_ATOKEN",
            )
        )
        self.ZERO_ADDRESS_NOT_VALID = (
            ErrorsZERO_ADDRESS_NOT_VALIDContractFunction.factory(
                "ZERO_ADDRESS_NOT_VALID",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                abi_element_identifier="ZERO_ADDRESS_NOT_VALID",
            )
        )


class ErrorsContract(Contract):
    """A web3.py Contract class for the Errors contract."""

    abi: ABI = errors_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr(
        "0x611293610035600b8282823980515f1a60731461002957634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061055e575f3560e01c80638aa3ca4c116102ca578063c08a114611610191578063de24948c116100fa578063f10727db116100b4578063f9b6e9a11161008f578063f9b6e9a11461118d578063fa163a83146111ae578063fae82791146111cf578063fd1828ff146111f0575f80fd5b8063f10727db1461112a578063f18206521461114b578063f479ea111461116c575f80fd5b8063de24948c14611065578063e02f07ee14611086578063e3fa20f5146110a6578063e4dd8b74146110c7578063e981483a146110e8578063f07f678514611109575f80fd5b8063d6f9fcde1161014b578063d6f9fcde14610f9f578063d9adda8514610fc0578063db3e2c5414610fe1578063dc191bd914611002578063dcc56db614611023578063dd1dd95f14611044575f80fd5b8063c08a114614610ed9578063c863808214610efa578063c899301a14610f1b578063cd23367c14610f3c578063d14bb17a14610f5d578063d1cd8b1d14610f7e575f80fd5b8063a4868dca11610233578063b4a45730116101ed578063b4a4573014610e14578063b5e7936614610e35578063b68774e914610e55578063b7f5e22414610e76578063b87041c214610e97578063bad8308c14610eb8575f80fd5b8063a4868dca14610d4f578063a8c9785314610d70578063ab883ca014610d91578063abd351b114610db2578063ac75323614610dd3578063b051005414610df3575f80fd5b8063952633c511610284578063952633c514610c895780639527e9d914610caa57806399ce53f314610ccb578063a2797c8014610cec578063a2e976c614610d0d578063a3402a3814610d2e575f80fd5b80638aa3ca4c14610bc35780638b8b98d714610be45780638e83874814610c055780638eda46bd14610c265780638f7722b214610c4757806394f9fd8a14610c68575f80fd5b80634e01e3c1116104285780636b3f7cc71161039157806376ae8fca1161034b5780638596aad5116103265780638596aad514610b3f578063895f7dc814610b6057806389c5d45f14610b815780638a34400014610ba2575f80fd5b806376ae8fca14610adc5780637aa0767e14610afd5780637fea6f3614610b1e575f80fd5b80636b3f7cc714610a165780636cd3cfbc14610a37578063712f536a14610a5857806373dea5e314610a7957806374459b1414610a9a578063747fa55614610abb575f80fd5b80635d9c76c0116103e25780635d9c76c01461095157806360c3de80146109725780636177a9321461099257806361c111d2146109b357806365a83bab146109d457806365e7ef4c146109f5575f80fd5b80634e01e3c11461088c5780634e3aed37146108ad5780634ef999ff146108ce5780634f77647b146108ef578063512674501461090f57806352ba9dbe14610930575f80fd5b80632c8e3b4c116104ca578063471df68511610484578063471df685146107c757806347ba93d8146107e857806347cf152314610809578063480702ae1461082a578063485c8ff61461084b5780634d86f3931461086b575f80fd5b80632c8e3b4c146107025780632eed17e814610722578063335763de14610743578063366eb54d1461076457806337930782146107855780634105ab65146107a6575f80fd5b8063227602451161051b578063227602451461063d57806322a734461461065e578063231ec1411461067f57806326bbd053146106a057806326e7b312146106c15780632926c971146106e1575f80fd5b8063084dfa0d1461056257806311d7b0061461059957806312dcade8146105b957806314dcfbbc146105da578063198d6a6b146105fb5780631abbb0011461061c575b5f80fd5b61058360405180604001604052806002815260200161062760f31b81525081565b6040516105909190611211565b60405180910390f35b610583604051806040016040528060018152602001603960f81b81525081565b610583604051806040016040528060028152602001610c4d60f21b81525081565b610583604051806040016040528060028152602001611c1b60f11b81525081565b61058360405180604001604052806002815260200161070760f31b81525081565b61058360405180604001604052806002815260200161383760f01b81525081565b61058360405180604001604052806002815260200161393960f01b81525081565b61058360405180604001604052806002815260200161343760f01b81525081565b610583604051806040016040528060028152602001610e4d60f21b81525081565b61058360405180604001604052806002815260200161363960f01b81525081565b610583604051806040016040528060018152602001603360f81b81525081565b610583604051806040016040528060028152602001610d0d60f21b81525081565b610583604051806040016040528060018152602001603560f81b81525081565b61058360405180604001604052806002815260200161035360f41b81525081565b61058360405180604001604052806002815260200161032360f41b81525081565b61058360405180604001604052806002815260200161333560f01b81525081565b61058360405180604001604052806002815260200161189960f11b81525081565b61058360405180604001604052806002815260200161072760f31b81525081565b61058360405180604001604052806002815260200161323360f01b81525081565b610583604051806040016040528060028152602001611b9960f11b81525081565b61058360405180604001604052806002815260200161323160f01b81525081565b610583604051806040016040528060028152602001611b1960f11b81525081565b610583604051806040016040528060018152602001601960f91b81525081565b61058360405180604001604052806002815260200161333160f01b81525081565b610583604051806040016040528060028152602001610ccd60f21b81525081565b61058360405180604001604052806002815260200161383360f01b81525081565b61058360405180604001604052806002815260200161033360f41b81525081565b610583604051806040016040528060018152602001601b60f91b81525081565b61058360405180604001604052806002815260200161323560f01b81525081565b61058360405180604001604052806002815260200161323760f01b81525081565b61058360405180604001604052806002815260200161313760f01b81525081565b610583604051806040016040528060018152602001600760fb1b81525081565b61058360405180604001604052806002815260200161393360f01b81525081565b61058360405180604001604052806002815260200161031360f41b81525081565b61058360405180604001604052806002815260200161353360f01b81525081565b61058360405180604001604052806002815260200161353560f01b81525081565b610583604051806040016040528060028152602001611a9960f11b81525081565b61058360405180604001604052806002815260200161064760f31b81525081565b61058360405180604001604052806002815260200161034360f41b81525081565b61058360405180604001604052806002815260200161343960f01b81525081565b61058360405180604001604052806002815260200161343160f01b81525081565b61058360405180604001604052806002815260200161313960f01b81525081565b61058360405180604001604052806002815260200161313560f01b81525081565b61058360405180604001604052806002815260200161191960f11b81525081565b61058360405180604001604052806002815260200161313360f01b81525081565b61058360405180604001604052806002815260200161036360f41b81525081565b610583604051806040016040528060028152602001611a1b60f11b81525081565b61058360405180604001604052806002815260200161333360f01b81525081565b61058360405180604001604052806002815260200161333760f01b81525081565b61058360405180604001604052806002815260200161393160f01b81525081565b61058360405180604001604052806002815260200161038360f41b81525081565b610583604051806040016040528060028152602001611c9b60f11b81525081565b61058360405180604001604052806002815260200161037360f41b81525081565b6105836040518060400160405280600281526020016106a760f31b81525081565b610583604051806040016040528060028152602001610d4d60f21b81525081565b61058360405180604001604052806002815260200161343560f01b81525081565b61058360405180604001604052806002815260200161363560f01b81525081565b61058360405180604001604052806002815260200161363360f01b81525081565b61058360405180604001604052806002815260200161343360f01b81525081565b61058360405180604001604052806002815260200161313160f01b81525081565b61058360405180604001604052806002815260200161373960f01b81525081565b61058360405180604001604052806002815260200161363760f01b81525081565b61058360405180604001604052806002815260200161373160f01b81525081565b61058360405180604001604052806002815260200161383560f01b81525081565b610583604051806040016040528060028152602001610c8d60f21b81525081565b610583604051806040016040528060018152602001603160f81b81525081565b61058360405180604001604052806002815260200161353160f01b81525081565b610583604051806040016040528060028152602001611a1960f11b81525081565b610583604051806040016040528060018152602001600d60fa1b81525081565b61058360405180604001604052806002815260200161323960f01b81525081565b61058360405180604001604052806002815260200161199960f11b81525081565b61058360405180604001604052806002815260200161353760f01b81525081565b610583604051806040016040528060028152602001611b9b60f11b81525081565b6105836040518060400160405280600281526020016106e760f31b81525081565b61058360405180604001604052806002815260200161353960f01b81525081565b610583604051806040016040528060028152602001610e0d60f21b81525081565b610583604051806040016040528060028152602001611c1960f11b81525081565b61058360405180604001604052806002815260200161373760f01b81525081565b610583604051806040016040528060028152602001610dcd60f21b81525081565b6105836040518060400160405280600281526020016106c760f31b81525081565b61058360405180604001604052806002815260200161363160f01b81525081565b61058360405180604001604052806002815260200161393560f01b81525081565b61058360405180604001604052806002815260200161333960f01b81525081565b61058360405180604001604052806002815260200161373360f01b81525081565b610583604051806040016040528060028152602001610d8d60f21b81525081565b61058360405180604001604052806002815260200161383960f01b81525081565b610583604051806040016040528060018152602001603760f81b81525081565b61058360405180604001604052806002815260200161199b60f11b81525081565b61058360405180604001604052806002815260200161383160f01b81525081565b61058360405180604001604052806002815260200161039360f41b81525081565b61058360405180604001604052806002815260200161066760f31b81525081565b610583604051806040016040528060028152602001611a9b60f11b81525081565b61058360405180604001604052806002815260200161393760f01b81525081565b61058360405180604001604052806002815260200161189b60f11b81525081565b610583604051806040016040528060028152602001611c9960f11b81525081565b610583604051806040016040528060028152602001611b1b60f11b81525081565b61058360405180604001604052806002815260200161191b60f11b81525081565b61058360405180604001604052806002815260200161373560f01b81525081565b5f602080835283518060208501525f5b8181101561123d57858101830151858201604001528201611221565b505f604082860101526040601f19601f830116850101925050509291505056fea2646970667358221220b96c38e6a75ee253bc2dd1eec40dc5d9ed420afac555558f10654f96ba4a89cf64736f6c63430008180033"
    )

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = ErrorsContractFunctions(errors_abi, self.w3, address)  # type: ignore

    functions: ErrorsContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = ErrorsContractFunctions(errors_abi, w3, None)

        return contract
