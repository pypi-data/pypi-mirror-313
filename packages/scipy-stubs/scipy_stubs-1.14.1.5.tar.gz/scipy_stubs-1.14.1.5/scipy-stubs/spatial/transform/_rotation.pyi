from collections.abc import Sequence

import numpy as np
import numpy.typing as npt
import optype.numpy as onp
from scipy._typing import Seed

class Rotation:
    @property
    def single(self, /) -> bool: ...
    def __init__(self, /, quat: npt.ArrayLike, normalize: bool = ..., copy: bool = ...) -> None: ...
    def __setstate_cython__(self, pyx_state: object, /) -> None: ...
    def __reduce_cython__(self, /) -> None: ...
    def __len__(self, /) -> int: ...
    def __getitem__(self, /, indexer: int | slice | npt.ArrayLike) -> Rotation: ...
    def __mul__(self, /, other: Rotation) -> Rotation: ...
    def __pow__(self, /, n: float, modulus: int | None) -> Rotation: ...
    def as_quat(self, /, canonical: bool = ..., *, scalar_first: bool = ...) -> onp.ArrayND[np.float64]: ...
    def as_matrix(self, /) -> onp.ArrayND[np.float64]: ...
    def as_rotvec(self, /, degrees: bool = ...) -> onp.ArrayND[np.float64]: ...
    def as_euler(self, /, seq: str, degrees: bool = ...) -> onp.ArrayND[np.float64]: ...
    def as_davenport(self, /, axes: npt.ArrayLike, order: str, degrees: bool = ...) -> onp.ArrayND[np.float64]: ...
    def as_mrp(self, /) -> onp.ArrayND[np.float64]: ...
    def apply(self, /, vectors: npt.ArrayLike, inverse: bool = ...) -> onp.ArrayND[np.float64]: ...
    def inv(self, /) -> Rotation: ...
    def magnitude(self, /) -> onp.ArrayND[np.float64] | float: ...
    def approx_equal(
        self, /, other: Rotation, atol: float | None = None, degrees: bool = ...
    ) -> onp.ArrayND[np.bool_] | bool: ...
    def mean(self, /, weights: npt.ArrayLike | None = ...) -> Rotation: ...
    def reduce(
        self,
        /,
        left: Rotation | None = ...,
        right: Rotation | None = ...,
        return_indices: bool = ...,
    ) -> Rotation | tuple[Rotation, onp.ArrayND[np.float64], onp.ArrayND[np.float64]]: ...
    @classmethod
    def from_quat(cls, quat: npt.ArrayLike, *, scalar_first: bool = ...) -> Rotation: ...
    @classmethod
    def from_matrix(cls, matrix: npt.ArrayLike) -> Rotation: ...
    @classmethod
    def from_rotvec(cls, rotvec: npt.ArrayLike, degrees: bool = ...) -> Rotation: ...
    @classmethod
    def from_euler(cls, seq: str, angles: float | npt.ArrayLike, degrees: bool = ...) -> Rotation: ...
    @classmethod
    def from_davenport(cls, axes: npt.ArrayLike, order: str, angles: float | npt.ArrayLike, degrees: bool = ...) -> Rotation: ...
    @classmethod
    def from_mrp(cls, mrp: npt.ArrayLike) -> Rotation: ...
    @classmethod
    def concatenate(cls, rotations: Sequence[Rotation]) -> Rotation: ...
    @classmethod
    def create_group(cls, group: str, axis: str = ...) -> Rotation: ...
    @classmethod
    def identity(cls, num: int | None = ...) -> Rotation: ...
    @classmethod
    def random(cls, num: int | None = ..., random_state: Seed | None = ...) -> Rotation: ...
    @classmethod
    def align_vectors(
        cls,
        a: npt.ArrayLike,
        b: npt.ArrayLike,
        weights: npt.ArrayLike | None = ...,
        return_sensitivity: bool = ...,
    ) -> tuple[Rotation, float] | tuple[Rotation, float, onp.ArrayND[np.float64]]: ...

class Slerp:
    times: onp.ArrayND
    timedelta: onp.ArrayND
    rotations: Rotation
    rotvecs: onp.ArrayND[np.float64]
    def __init__(self, /, times: npt.ArrayLike, rotations: Rotation) -> None: ...
    def __call__(self, /, times: npt.ArrayLike) -> Rotation: ...
