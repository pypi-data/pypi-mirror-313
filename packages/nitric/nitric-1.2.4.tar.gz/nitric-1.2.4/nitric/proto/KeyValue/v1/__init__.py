#
# Copyright (c) 2021 Nitric Technologies Pty Ltd.
#
# This file is part of Nitric Python 3 SDK.
# See https://github.com/nitrictech/python-sdk for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: nitric/proto/keyvalue/v1/keyvalue.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .... import proto as ___proto__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class Store(betterproto.Message):
    """Provides a Key/Value Store"""

    name: str = betterproto.string_field(1)
    """The store name"""


@dataclass(eq=False, repr=False)
class ValueRef(betterproto.Message):
    """ValueRef provides a unique identifier for a value"""

    store: str = betterproto.string_field(1)
    """The key/value store name"""

    key: str = betterproto.string_field(2)
    """The item's unique key within the store"""


@dataclass(eq=False, repr=False)
class Value(betterproto.Message):
    """Value provides a return value type"""

    ref: "___proto__.KeyValueV1ValueRef" = betterproto.message_field(1)
    """ValueRef of the key/value pair, which includes the store and key"""

    content: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(2)
    """The content (JSON object)"""


@dataclass(eq=False, repr=False)
class KeyValueGetRequest(betterproto.Message):
    ref: "___proto__.KeyValueV1ValueRef" = betterproto.message_field(1)
    """
    ValueRef of the key/value pair to get, which includes the store and key
    """


@dataclass(eq=False, repr=False)
class KeyValueGetResponse(betterproto.Message):
    value: "___proto__.KeyValueV1Value" = betterproto.message_field(1)
    """The retrieved value"""


@dataclass(eq=False, repr=False)
class KeyValueSetRequest(betterproto.Message):
    ref: "___proto__.KeyValueV1ValueRef" = betterproto.message_field(1)
    """
    ValueRef of the key/value pair to set, which includes the store and key
    """

    content: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(3)
    """The value content to store (JSON object)"""


@dataclass(eq=False, repr=False)
class KeyValueSetResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class KeyValueDeleteRequest(betterproto.Message):
    ref: "___proto__.KeyValueV1ValueRef" = betterproto.message_field(1)
    """
    ValueRef of the key/value pair to delete, which includes the store and key
    """


@dataclass(eq=False, repr=False)
class KeyValueDeleteResponse(betterproto.Message):
    pass


class KeyValueStub(betterproto.ServiceStub):
    async def get(
        self,
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "___proto__.KeyValueV1KeyValueGetResponse":
        return await self._unary_unary(
            "/nitric.proto.KeyValue.v1.KeyValue/Get",
            proto_key_value_v1_key_value_get_request,
            ___proto__.KeyValueV1KeyValueGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set(
        self,
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "___proto__.KeyValueV1KeyValueSetResponse":
        return await self._unary_unary(
            "/nitric.proto.KeyValue.v1.KeyValue/Set",
            proto_key_value_v1_key_value_set_request,
            ___proto__.KeyValueV1KeyValueSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "___proto__.KeyValueV1KeyValueDeleteResponse":
        return await self._unary_unary(
            "/nitric.proto.KeyValue.v1.KeyValue/Delete",
            proto_key_value_v1_key_value_delete_request,
            ___proto__.KeyValueV1KeyValueDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class KeyValueBase(ServiceBase):
    async def get(self) -> "___proto__.KeyValueV1KeyValueGetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(self) -> "___proto__.KeyValueV1KeyValueSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(self) -> "___proto__.KeyValueV1KeyValueDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get(
        self,
        stream: "grpclib.server.Stream[___proto__.KeyValueV1KeyValueGetRequest, ___proto__.KeyValueV1KeyValueGetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get(request)
        await stream.send_message(response)

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[___proto__.KeyValueV1KeyValueSetRequest, ___proto__.KeyValueV1KeyValueSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[___proto__.KeyValueV1KeyValueDeleteRequest, ___proto__.KeyValueV1KeyValueDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nitric.proto.KeyValue.v1.KeyValue/Get": grpclib.const.Handler(
                self.__rpc_get,
                grpclib.const.Cardinality.UNARY_UNARY,
                ___proto__.KeyValueV1KeyValueGetRequest,
                ___proto__.KeyValueV1KeyValueGetResponse,
            ),
            "/nitric.proto.KeyValue.v1.KeyValue/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                ___proto__.KeyValueV1KeyValueSetRequest,
                ___proto__.KeyValueV1KeyValueSetResponse,
            ),
            "/nitric.proto.KeyValue.v1.KeyValue/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                ___proto__.KeyValueV1KeyValueDeleteRequest,
                ___proto__.KeyValueV1KeyValueDeleteResponse,
            ),
        }
