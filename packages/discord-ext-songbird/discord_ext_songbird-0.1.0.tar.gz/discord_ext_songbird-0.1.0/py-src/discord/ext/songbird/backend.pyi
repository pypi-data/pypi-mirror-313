import io
from typing import Any, Callable, Optional, Coroutine, TYPE_CHECKING

if TYPE_CHECKING:
    from .track import Track

UpdateHook = Callable[[Optional[int], bool, bool], Coroutine[Any, Any, None]]

class SongbirdError(Exception): ...
class JoinError(SongbirdError): ...
class ConnectionNotInitialized(SongbirdError): ...

class SongbirdBackend:
    queue: QueueHandler

    def __init__(self, channel_id: int) -> None: ...
    async def start(self, update_hook: UpdateHook, client_id: int, guild_id: int) -> None: ...
    async def on_server_update(self, endpoint: str, token: str) -> None: ...
    async def on_voice_state_update(self, session_id: str, channel_id: Optional[int]) -> None: ...
    async def connect(self, timeout: float, self_deaf: bool, self_mute: bool) -> None: ...
    async def leave(self) -> None: ...
    async def mute(self, mute: bool) -> None: ...
    async def deafen(self, deaf: bool) -> None: ...
    def is_mute(self) -> bool: ...
    def is_deaf(self) -> bool: ...
    async def move_to(self, channel_id: int) -> None: ...
    async def play_source(self, source: AudioSource) -> PlayerHandler: ...

class SourceComposed: ...

class AudioSource:
    def get_source(self) -> SourceComposed: ...

class RawBufferSource(AudioSource):
    def __init__(self, source: io.BufferedIOBase): ...

class PlayerHandler:
    queue: QueueHandler

    def play(self) -> None: ...
    def stop(self) -> None: ...
    def set_volume(self, volume: float) -> None: ...

class QueueHandler:
    def enqueue(self, track: Track) -> None: ...
    def dequeue(self, index: int) -> None: ...
    def skip(self) -> None: ...
    def stop(self) -> None: ...
    def resume(self) -> None:
        """
        Resumes the queue.
        :return:
        """
        ...

class IntoTrack:
    def __init__(self, source: AudioSource, volume: float, is_loop: bool, loop_count: Optional[int] = None) -> None: ...
