from pydantic import BaseModel, ConfigDict, ValidationError
from redis_om import JsonModel, EmbeddedJsonModel, Field
from enum import Enum
from datetime import date, datetime, time, timedelta

from typing import Dict, List
from enum import Enum

class Split(str, Enum):

    dev = 'dev'
    test = 'test'
    val = 'val'
    train = 'train'
    
# Questions as from the Digi dataset
class Question(BaseModel, use_enum_values=True):
    question_number: str
    question: str
    correct_answer: str
    has_media: bool = False
    dataset: str | None = None
    qualification: str
    level: str
    section: str | None = None
    session: str | None = None
    session_name: str | None = None
    split: Split
    answer_choices: Dict[str, str]
    marks: int = 1

    def prompt(self):
        return f"Q: {self.question}\n"+("\n" +"\n".join(o+': '+v for o,v in self.answer_choices.items()) if self.answer_choices else "")

# Questions generated by the model
class GeneratedQuestion(BaseModel):
    question_number: str | int
    question: str
    correct_answer: str | None #= ""
    options: List[str] | None #= []
    
    def __str__(self):
        return f"N: {self.question_number}\nQ: {self.question}\n"+ ("\n".join([o for i,o in enumerate(self.options)]) if self.options else "")

class GeneratedQuestionnaire(BaseModel):
    questionnaire: list[GeneratedQuestion]
    
    def __str__(self):
        return "\n".join(str(q) for q in self.questionnaire)
            
# This is handled better by Open Source Models
class GeneratedQuestionWithDefaults(BaseModel):
    question_number: str | int
    question: str
    correct_answer: str = ""
    options: List[str] = []
    
    def __str__(self):
        return f"N: {self.question_number}\nQ: {self.question}\n"+ ("\n".join([o for i,o in enumerate(self.options)]) if self.options else "")

class GeneratedQuestionnaireWithDefaults(BaseModel):
    questionnaire: list[GeneratedQuestionWithDefaults]
    
    def __str__(self):
        return "\n".join(str(q) for q in self.questionnaire)
    

class ChatRole(str, Enum):
     system = 'system'
     user = 'user'
     assistant = 'assistant'

class ChatMessage(EmbeddedJsonModel, use_enum_values=True):
    role: ChatRole
    content : str

class Chat(JsonModel):
    user: str = Field(index=True)
    agent: str
    ts: datetime
    msgs: List[ChatMessage]
    summary: str | None = None




class Session(EmbeddedJsonModel):

    session: int #= Field(..., description="Session number")
    focus: str
    content_outcome: str
    concept_key_terms: str
    resources: str #= Field(..., description="SOW resources")
    estimated_time: str

class StatementOfWork(JsonModel):
   #school: str = Field(index=True)
   qualification: str = Field(index=True)
   level: str
   glh: str | None = None # Guided Learning Hours
   tqt: str | None = None # Total Qualification Time
   description: str | None = None
   learning_aims: str | None = None
   skills_areas: str | None = None
   notes: str | None = None
   sessions: List[Session]


class Invitation(JsonModel):
    email: str = Field(index=True)
    invitation_key: str
    accepted: bool = False
    accepted_on: datetime | None = None
