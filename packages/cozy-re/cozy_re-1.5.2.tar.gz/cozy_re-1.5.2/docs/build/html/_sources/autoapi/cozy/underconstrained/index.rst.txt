cozy.underconstrained
=====================

.. py:module:: cozy.underconstrained


Attributes
----------

.. autoapisummary::

   cozy.underconstrained.underconstrained_preset


Classes
-------

.. autoapisummary::

   cozy.underconstrained.SimConcretizationStrategyUnderconstrained
   cozy.underconstrained.Box
   cozy.underconstrained.DefaultMemoryUnderconstrained


Module Contents
---------------

.. py:class:: SimConcretizationStrategyUnderconstrained(*args, **kwargs)

   Bases: :py:obj:`angr.concretization_strategies.SimConcretizationStrategyNorepeatsRange`


   This class extends SimConcretizationStrategyNorepeatsRange, making it suitable for use with underconstrained
   execution. The primary use case of this class is to provide concretization strategies for when memory contents
   are underconstrained/symbolic. The main problem occurs when reading/writing symbolic addresses, which means
   those addresses must be concretized. The strategy we employ is to allocate a fresh chunk of memory for
   fresh symbols, giving them sufficient scratch space to store their members.

   Initializes the base SimConcretizationStrategy.

   :param filter: A function, taking arguments of (SimMemory, claripy.AST) that determins
                  if this strategy can handle resolving the provided AST.
   :param exact: A flag (default: True) that determines if the convenience resolution
                 functions provided by this class use exact or approximate resolution.


   .. py:method:: constrain_addr(memory, addr)


   .. py:method:: multi_concretize(memory, addr)


   .. py:method:: _concretize(memory, addr, **kwargs)

      Should be implemented by child classes to handle concretization.
      :param **kwargs:



   .. py:method:: _any(*args, **kwargs)

      Gets any solution of an address.



.. py:class:: Box(value)

.. py:class:: DefaultMemoryUnderconstrained(*args, **kwargs)

   Bases: :py:obj:`angr.storage.memory_mixins.DefaultMemory`


   The primary goal of this class is to provide a wrapper for memory use in underconstrained symbolic execution.
   Here we record all the fresh symbols that are created whenever underconstrained memory is read.


   .. py:method:: get_default_backer()


   .. py:method:: set_default_backer(backer: angr.storage.memory_mixins.DefaultMemory)


   .. py:method:: set_symbols(symbols: list[claripy.BVS])


   .. py:method:: get_symbols() -> list[claripy.BVS]


   .. py:method:: copy(*args, **kwargs)

      Should return a copy of the plugin without any state attached. Should check the memo first, and add itself to
      memo if it ends up making a new copy.

      In order to simplify using the memo, you should annotate implementations of this function with
      ``SimStatePlugin.memo``

      The base implementation of this function constructs a new instance of the plugin's class without calling its
      initializer. If you super-call down to it, make sure you instanciate all the fields in your copy method!

      :param memo:    A dictionary mapping object identifiers (id(obj)) to their copied instance.  Use this to avoid
                      infinite recursion and diverged copies.



   .. py:method:: _default_value(addr, size, **kwargs)

      Override this method to provide default values for a variety of edge cases and base cases.

      :param addr:    If this value is being filled to provide a default memory value, this will be its address.
                      Otherwise, None.
      :param size:    The size in bytes of the value to return
      :param name:    A descriptive identifier for the value, for if a symbol is created.

      The ``inspect``, ``events``, and ``key`` parameters are for ``state.solver.Unconstrained``, if it is used.



.. py:data:: underconstrained_preset

